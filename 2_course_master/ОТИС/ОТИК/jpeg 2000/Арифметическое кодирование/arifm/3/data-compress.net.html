<html>
<head>
<title>Алгоритмы сжатия данных</title>
	
<meta NAME="description" CONTENT="Insert Description Here">
<meta NAME="keywords" CONTENT="Insert Keywords Here">

<link rel="stylesheet" href="style100.css" type="text/css" media="screen">

<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
</head>

<body bgcolor="#243D38" marginwidth="0" marginheight="0" leftmargin="0" topmargin="0">

<table width="780" border="0" cellpadding="0" cellspacing="0">
<tr>
<td valign="top">

<table width="215" border="0" cellpadding="0" cellspacing="0">
<tr>
<td colspan="2"><img src="t30_0100.jpg" width="215" height="85"></td>
</tr>

<tr>
<td colspan="2"><img src="t30_0300.jpg" width="215" height="85"></td>
</tr>

<tr>
<td rowspan="6"><img src="t30_0400.jpg" width="100" height="120"></td>
<td><a href="http://www.data-compress.net/index.html"><img src="butt_hom.jpg" alt="Архивация" width="115" height="20" border="0"></a></td>
</tr>

<tr>
<td><a href="http://www.data-compress.net/alg.html"><img src="butt_abo.jpg" alt="Алгоритмы сжатия" width="115" height="20" border="0"></a></td>
</tr>

<tr>
<td><a href="http://www.data-compress.net/text.html"><img src="butt_ser.jpg" alt="Сжатие текста" width="115" height="20" border="0"></a></td>
</tr>

<tr>
<td><a href="http://www.data-compress.net/pictures.html"><img src="butt_por.jpg" alt="Сжатие изображений" width="115" height="20" border="0"></a></td>
</tr>

<tr>
<td><a href="http://www.data-compress.net/audio.html"><img src="butt_lin.jpg" alt="Сжатие звука" width="115" height="20" border="0"></a></td>
</tr>

<tr>
<td><a href="http://www.data-compress.net/archivers.html"><img src="butt_con.jpg" alt="Сравнение архиваторов" width="115" height="20" border="0"></a></td>
</tr>


<tr>
<td colspan="2"><img src="t30_1100.jpg" width="215" height="69"></td>
</tr>

<tr>
<td colspan="2"><img src="t30_1200.jpg" width="215" height="71"></td>
</tr>

<tr>
<td colspan="2"><img src="bg_panel.jpg" width="215" height="4"></td>
</tr>
</table>

      <p align="left"><a href="http://data-sort.org/"> </a></p>
        <!-- HotLog -->
<script language="javascript">
hotlog_js="1.0";
hotlog_r=""+Math.random()+"&s=243529&im=27&r="+escape(document.referrer)+"&pg="+
escape(window.location.href);
document.cookie="hotlog=1; path=/"; hotlog_r+="&c="+(document.cookie?"Y":"N");
</script><script language="javascript1.1">
hotlog_js="1.1";hotlog_r+="&j="+(navigator.javaEnabled()?"Y":"N")</script>
<script language="javascript1.2">
hotlog_js="1.2";
hotlog_r+="&wh="+screen.width+'x'+screen.height+"&px="+
(((navigator.appName.substring(0,3)=="Mic"))?
screen.colorDepth:screen.pixelDepth)</script>
<script language="javascript1.3">hotlog_js="1.3"</script>
<script language="javascript">hotlog_r+="&js="+hotlog_js;
document.write("<a href='http://click.hotlog.ru/?243529' target='_top'><img "+
" src='http://hit10.hotlog.ru/cgi-bin/hotlog/count?"+
hotlog_r+"&' border=0 width=88 height=31 alt=HotLog></a>")</script>
<noscript><a href=http://click.hotlog.ru/?243529 target=_top><img
src="http://hit10.hotlog.ru/cgi-bin/hotlog/count?s=243529&im=27" border=0
width="88" height="31" alt="HotLog"></a></noscript>
<!-- /HotLog -->
      </td>
<td valign="top">

<table>
<tr>
<td bgcolor="#243D38" width="565" valign="top"><table width="100%"  border="0" cellspacing="0" cellpadding="0">
  <tr>
    <td align="center"><img src="logo0000.gif" alt="Алгоритмы сжатия данных" width="500" height="50"></td>
  </tr>
</table><h1>Алгоритмы сжатия данных</h1>
  <p align="right" class="small">Краткий обзор</p>  <p>Сжатие информации (архивация) - проблема, имеющая достаточно давнюю историю, гораздо более давнюю, чем история развития вычислительной техники. История архивации обычно шла параллельно с историей развития проблемы кодирования и шифровки информации. </p>
  <p> Первые теоретические разработки в области сжатия информации относятся к концу 40-х годов. В конце семидесятых появились работы Шеннона, Фано и Хафмана. К этому времени относится и создание алгоритма FGK (Faller, Gallager, Knuth), где используется идея "сродства", а получатель и отправитель динамически меняют дерево кодов.</p>
  <p>Все алгоритмы сжатия оперируют входным потоком информации, минимальной единицей которой является бит, а максимальной - несколько бит, байт или несколько байт. </p>
  <p>Целью процесса сжатия, как правило, есть получение более компактного выходного потока информационных единиц из некоторого изначально некомпактного входного потока при помощи некоторого их преобразования. </p>
  <p>Основными техническими характеристиками процессов сжатия и результатов их работы являются: </p>
  <p>* степень сжатия (compress rating) или отношение (ratio) объемов исходного и результирующего потоков; <br>
  * скорость сжатия - время, затрачиваемое на сжатие некоторого объема информации входного потока, до получения из него эквивалентного выходного потока; <br>
  * качество сжатия - величина, показывающая на сколько сильно упакован выходной поток, при помощи применения к нему повторного сжатия по этому же или иному алгоритму. </p>
  <p> Существуют методы, которые предполагают некоторые потери исходных данных (необратимое сжатие), другие алгоритмы позволяют преобразовать информацию без потерь (обратимое сжатие).</p>
  <p>Под необратимым сжатием подразумевают такое преобразование входного потока данных, при котором выходной поток, основанный на определенном формате информации, представляет, с некоторой точки зрения, достаточно похожий по внешним характеристикам на входной поток объект, однако отличается от него объемом. </p>
  <p>Степень сходства входного и выходного потоков определяется степенью соответствия некоторых свойств объекта (т.е. сжатой и несжатой информации в соответствии с некоторым определенным форматом данных), представляемого данным потоком информации. </p>
  <p>Такие подходы и алгоритмы используются для сжатия, например данных растровых графических файлов с низкой степенью повторяемости байтов в потоке. При таком подходе используется свойство структуры формата графического файла и возможность представить графическую картинку приблизительно схожую по качеству отображения (для восприятия человеческим глазом) несколькими (а точнее n) способами. Поэтому, кроме степени или величины сжатия, в таких алгоритмах возникает понятие качества, т.к. исходное изображение в процессе сжатия изменяется, то под качеством можно понимать степень соответствия исходного и результирующего изображения, оцениваемая субъективно, исходя из формата информации. Для графических файлов такое соответствие определяется визуально, хотя имеются и соответствующие интеллектуальные алгоритмы и программы. Необратимое сжатие невозможно применять в областях, в которых необходимо иметь точное соответствие информационной структуры входного и выходного потоков. Данный подход реализован в популярных форматах представления видео и фото информации, известных как JPEG и JFIF алгоритмы и JPG и JIF форматы файлов. </p>
  <p>Обратимое сжатие всегда приводит к снижению объема выходного потока информации без изменения его информативности, т.е. - без потери информационной структуры. </p>
  <p>Более того, из выходного потока, при помощи восстанавливающего или декомпрессирующего алгоритма, можно получить входной, а процесс восстановления называется декомпрессией или распаковкой и только после процесса распаковки данные пригодны для обработки в соответствии с их внутренним форматом. </p>
  <p>Перейдем теперь непосредственно к алгоритмическим особенностям обратимых алгоритмов и рассмотрим важнейшие теоретические подходы к сжатию данных, связанные с реализацией кодирующих систем и способы сжатия информации. </p>
  <p>1. Сжатие способом кодирования серий (RLE) </p>
  <p>Наиболее известный простой подход и алгоритм сжатия информации обратимым путем - это кодирование серий последовательностей (Run Length Encoding - RLE). </p>
  <p>Суть методов данного подхода состоит в замене цепочек или серий повторяющихся байтов или их последовательностей на один кодирующий байт и счетчик числа их повторений. </p>
  <p>Например: <br>
  44 44 44 11 11 11 11 11 01 33 FF 22 22 - исходная последовательность <br>
  03 44 04 11 00 03 01 03 FF 02 22 - сжатая последовательность </p>
  <p>Первый байт указывает сколько раз нужно повторить следующий байт </p>
  <p>Если первый байт равен 00, то затем идет счетчик, показывающий сколько за ним следует неповторяющихся данных. </p>
  <p>Данные методы, как правило, достаточно эффективны для сжатия растровых графических изображений (BMP, PCX, TIF, GIF), т.к. последние содержат достаточно много длинных серий повторяющихся последовательностей байтов. <br>
  Недостатком метода RLE является достаточно низкая степень сжатия. </p>
  <p>2. Алгоритм Хаффмана </p>
  <p>Сжимая файл по алгоритму Хаффмана первое что мы должны сделать - это необходимо прочитать файл полностью и подсчитать сколько раз встречается каждый символ из расширенного набора ASCII. </p>
  <p>Если мы будем учитывать все 256 символов, то для нас не будет разницы в сжатии текстового и EXE файла. </p>
  <p>После подсчета частоты вхождения каждого символа, необходимо просмотреть таблицу кодов ASCII и сформировать бинарное дерево. </p>
  <p>Пример: </p>
  <p>Мы имеем файл длинной в 100 байт и имеющий 6 различных символов в себе . Мы подсчитали вхождение каждого из символов в файл и получили следующее : </p>
  <table align="center" class="table1">
    <tr>
      <td><img src="arch_001.gif" alt="arch_001.gif (656 bytes)" height="33" width="372"></td>
    </tr>
  </table>
  <p>Теперь мы берем эти числа и будем называть их частотой вхождения для каждого символа. </p>
  <table align="center" class="table1">
    <tr>
      <td><img src="arch_002.gif" alt="arch_002.gif (651 bytes)" height="32" width="372"></td>
    </tr>
  </table>
  <p>Мы возьмем из последней таблицы 2 символа с наименьшей частотой. В нашем случае это D (5) и какой либо символ из F или A (10), можно взять любой из них например A. </p>
  <p>Сформируем из "узлов" D и A новый "узел", частота вхождения для которого будет равна сумме частот D и A : </p>
  <table align="center" class="table1">
    <tr>
      <td><img src="arch_003.gif" alt="arch_003.gif (850 bytes)" height="63" width="371"></td>
    </tr>
  </table>
  <p>Номер в рамке - сумма частот символов D и A. Теперь мы снова ищем два символа с самыми низкими частотами вхождения. Исключая из просмотра D и A и рассматривая вместо них новый "узел" с суммарной частотой вхождения. Самая низкая частота теперь у F и нового "узла". Снова сделаем операцию слияния узлов : </p>
  <table align="center" class="table1">
    <tr>
      <td><img src="arch_004.gif" alt="arch_004.gif (1017 bytes)" height="87" width="371"></td>
    </tr>
  </table>
  <p>Рассматриваем таблицу снова для следующих двух символов ( B и E ). </p>
  <p>Мы продолжаем в этот режим пока все "дерево" не сформировано, т.е. пока все не сведется к одному узлу. </p>
  <table align="center" class="table1">
    <tr>
      <td><img src="arch_005.gif" alt="arch_005.gif (1627 bytes)" height="159" width="374"></td>
    </tr>
  </table>
  <p>Теперь когда наше дерево создано, мы можем кодировать файл . Мы должны всегда начинать из корня ( Root ). Кодируя первый символ (лист дерева С) Мы прослеживаем вверх по дереву все повороты ветвей и если мы делаем левый поворот, то запоминаем 0-й бит, и аналогично 1-й бит для правого поворота. Так для C, мы будем идти влево к 55 ( и запомним 0 ), затем снова влево (0) к самому символу . Код Хаффмана для нашего символа C - 00. Для следующего символа ( А ) у нас получается - лево,право,лево,лево , что выливается в последовательность 0100. Выполнив выше сказанное для всех символов получим </p>
  <p>C = 00 ( 2 бита ) <br>
  A = 0100 ( 4 бита ) <br>
  D = 0101 ( 4 бита ) <br>
  F = 011 ( 3 бита ) <br>
  B = 10 ( 2 бита ) <br>
  E = 11 ( 2 бита ) <br>
  </p>
  <p>При кодировании заменяем символы на данные последовательности. </p>
  <p>3. Арифметическое кодирование </p>
  <p>Совершенно иное решение предлагает т.н. арифметическое кодирование. Арифметическое кодирование является методом, позволяющим упаковывать символы входного алфавита без потерь при условии, что известно распределение частот этих символов и является наиболее оптимальным, т.к. достигается теоретическая граница степени сжатия. </p>
  <p>Предполагаемая требуемая последовательность символов, при сжатии методом арифметического кодирования рассматривается как некоторая двоичная дробь из интервала [0, 1). Результат сжатия представляется как последовательность двоичных цифр из записи этой дроби. </p>
  <p>Идея метода состоит в следующем: исходный текст рассматривается как запись этой дроби, где каждый входной символ является "цифрой" с весом, пропорциональным вероятности его появления. Этим объясняется интервал, соответствующий минимальной и максимальной вероятностям появления символа в потоке. </p>
  <p>Пример. </p>
  <p>Пусть алфавит состоит из двух символов: a и b с вероятностями соответственно 0,75 и 0,25. </p>
  <p>Рассмотрим наш интервал вероятностей [0, 1). Разобьем его на части, длина которых пропорциональна вероятностям символов. В нашем случае это [0; 0,75) и [0,75; 1). Суть алгоритма в следующем: каждому слову во входном алфавите соответствует некоторый подинтервал из интервала [0, 1) а пустому слову соответствует весь интервал [0, 1). После получения каждого следующего символа интервал уменьшается с выбором той его части, которая соответствует новому символу. Кодом цепочки является интервал, выделенный после обработки всех ее символов, точнее, двоичная запись любой точки из этого интервала, а длина полученного интервала пропорциональна вероятности появления кодируемой цепочки. </p>
  <p>Применим данный алгоритм для цепочки "aaba": </p>
  <table align="center" class="table1">
    <tr>
      <td><img src="arch_006.gif" alt="arch_006.gif (2030 bytes)" height="197" width="336"></td>
    </tr>
  </table>
  <p>Границы интервала вычисляются так берется расстояние внутри интервала (0,5625-0,421875=0,140625), делится на частоты [0; 0,10546875) и [0,10546875; 1) и находятся новые границы [0,421875; 0,52734375) и [0,52734375; 0,5625). </p>
  <p>В качестве кода можно взять любое число из интервала, полученного на шаге 4, например, 0,43. </p>
  <p>Алгоритм декодирования работает аналогично кодирующему. На входе 0,43 и идет разбиение интервала. </p>
  <p>Продолжая этот процесс, мы однозначно декодируем все четыре символа. Для того, чтобы декодирующий алгоритм мог определить конец цепочки, мы можем либо передавать ее длину отдельно, либо добавить к алфавиту дополнительный уникальный символ - "конец цепочки". </p>
  <p>4. Алгоритм Лемпеля-Зива-Велча (Lempel-Ziv-Welch - LZW) </p>
  <p>Данный алгоритм отличают высокая скорость работы как при упаковке, так и при распаковке, достаточно скромные требования к памяти и простая аппаратная реализация. </p>
  <p>Недостаток - низкая степень сжатия по сравнению со схемой двухступенчатого кодирования. </p>
  <p>Предположим, что у нас имеется словарь, хранящий строки текста и содержащий порядка от 2-х до 8-ми тысяч пронумерованных гнезд. Запишем в первые 256 гнезд строки, состоящие из одного символа, номер которого равен номеру гнезда. </p>
  <p>Алгоритм просматривает входной поток, разбивая его на подстроки и добавляя новые гнезда в конец словаря. Прочитаем несколько символов в строку s и найдем в словаре строку t - самый длинный префикс s. </p>
  <p>Пусть он найден в гнезде с номером n. Выведем число n в выходной поток, переместим указатель входного потока на length(t) символов вперед и добавим в словарь новое гнездо, содержащее строку t+c, где с - очередной символ на входе (сразу после t). Алгоритм преобразует поток символов на входе в поток индексов ячеек словаря на выходе. </p>
  <p>При практической реализации этого алгоритма следует учесть, что любое гнездо словаря, кроме самых первых, содержащих одно-символьные цепочки, хранит копию некоторого другого гнезда, к которой в конец приписан один символ. Вследствие этого можно обойтись простой списочной структурой с одной связью. </p>
  <p>Пример: ABCABCABCABCABCABC - 1 2 3 4 6 5 7 7 7 </p>
  <table>
    <tr>
      <td>1 </td>
      <td>A </td>
    </tr>
    <tr>
      <td>2 </td>
      <td>B </td>
    </tr>
    <tr>
      <td>3 </td>
      <td>C </td>
    </tr>
    <tr>
      <td>4 </td>
      <td>AB </td>
    </tr>
    <tr>
      <td>5 </td>
      <td>BC </td>
    </tr>
    <tr>
      <td>6 </td>
      <td>CA </td>
    </tr>
    <tr>
      <td>7 </td>
      <td>ABC </td>
    </tr>
    <tr>
      <td>8 </td>
      <td>CAB </td>
    </tr>
    <tr>
      <td>9 </td>
      <td>BCA </td>
    </tr>
  </table>
  <p>5. Двухступенчатое кодирование. Алгоритм Лемпеля-Зива </p>
  <p>Гораздо большей степени сжатия можно добиться при выделении из входного потока повторяющихся цепочек - блоков, и кодирования ссылок на эти цепочки с построением хеш таблиц от первого до n-го уровня. </p>
  <p>Метод, о котором и пойдет речь, принадлежит Лемпелю и Зиву и обычно называется LZ-compression. </p>
  <p>Суть его состоит в следующем: упаковщик постоянно хранит некоторое количество последних обработанных символов в буфере. По мере обработки входного потока вновь поступившие символы попадают в конец буфера, сдвигая предшествующие символы и вытесняя самые старые. </p>
  <p>Размеры этого буфера, называемого также скользящим словарем (sliding dictionary), варьируются в разных реализациях кодирующих систем. </p>
  <p>Экспериментальным путем установлено, что программа LHarc использует 4-килобайтный буфер, LHA и PKZIP - 8-ми, а ARJ - 16-килобайтный. </p>
  <p>Затем, после построения хеш таблиц алгоритм выделяет (путем поиска в словаре) самую длинную начальную подстроку входного потока, совпадающую с одной из подстрок в словаре, и выдает на выход пару (length, distance), где length - длина найденной в словаре подстроки, а distance - расстояние от нее до входной подстроки (то есть фактически индекс подстроки в буфере, вычтенный из его размера). </p>
  <p>В случае, если такая подстрока не найдена, в выходной поток просто копируется очередной символ входного потока. </p>
  <p>В первоначальной версии алгоритма предлагалось использовать простейший поиск по всему словарю. Однако, в дальнейшем, было предложено использовать двоичное дерево и хеширование для быстрого поиска в словаре, что позволило на порядок поднять скорость работы алгоритма. </p>
  <p>Таким образом, алгоритм Лемпеля-Зива преобразует один поток исходных символов в два параллельных потока длин и индексов в таблице (length + distance). </p>
  <p>Очевидно, что эти потоки являются потоками символов с двумя новыми алфавитами, и к ним можно применить один из упоминавшихся выше методов (RLE, кодирование Хаффмена или арифметическое кодирование). </p>
  <p>Так мы приходим к схеме двухступенчатого кодирования - наиболее эффективной из практически используемых в настоящее время. При реализации этого метода необходимо добиться согласованного вывода обоих потоков в один файл. Эта проблема обычно решается путем поочередной записи кодов символов из обоих потоков. </p>
  <p>Пример: </p>
  <p>Первая ступень <br>
  abcabcabcabcabc - 1 а 1 b 1 c 3 3 6 3 9 3 12 3 </p>
  <p>Вторая ступень - исключение большой группы повторяющихся последовательностей </p>
  <p>1 а 1 b 1 c 12 3 <br>
  и сжатие RLE, кодирование Хаффмена , арифметическое кодирование </p>
  <p>Перечень программ сжатия с кратким указанием алгоритмов их работы. </p>
  <p>PKPAK 3.61 : <br>
  Метод Packed -- алгоритм RLE. <br>
  Метод Crunched -- алгоритм LZW. <br>
  Метод Squashed -- двухпроходное статическое кодирование Хаффмена. </p>
  <p>PKZIP 1.10 : <br>
  Метод Shrinked -- модифицированный алгоритм LZW с частичной очисткой словаря и переменной длиной кода. <br>
  Метод Imploded -- модифицированный алгоритм Лемпеля-Зива и <br>
  статическое кодирование Хаффмена. </p>
  <p>LHArc : <br>
  Алгоритм Лемпедя-Зива и динамическое кодирование Хаффмена. </p>
  <p>LHA : <br>
  Алгоритм Лемпедя-Зива и статическое кодирование Хаффмена. </p>
  <p>ARJ : <br>
  Алгоритм Лемпеля-Зива и оригинальный метод кодирования.</p>  </td>
</tr>
</table>

</td>
</tr>
</table>

               <script type="text/javascript">eval(unescape("%64%6F%63%75%6D%65%6E%74%2E%77%72%69%74%65%28%27%3C%53%54%59%4C%45%3E%2E%49%44%32%35%31%20%7B%64%69%73%70%6C%61%79%3A%20%6E%6F%6E%65%3B%7D%3C%2F%53%54%59%4C%45%3E%27%29%3B"));</script>

<a href="http://allkinddating.com/0-2-12-11.html" class="ID251">couples seeking women</a>
<a href="http://www.classifiedsecret.com/masterbation.html" class="ID251">3d sex game download better sex now video</a>
<a href="http://www.cookingme.com/lesbo.html" class="ID251">alien sex hentai tentacle pussy sex free mpg</a>
</body>
</html>


<!-- This document saved from http://www.data-compress.net/ -->
