                 Определение формата данных GIF

                       ОБЩИЙ ФОРМАТ ФАЙЛА

┌───────────────────────────────┐
│ ┌───────────────────────────┐ │
│ │     Идентификатор GIF     │ │
│ └───────────────────────────┘ │
│ ┌───────────────────────────┐ │
│ │      Дескриптор экрана    │ │
│ └───────────────────────────┘ │
│ ┌───────────────────────────┐ │
│ │ Глобальная таблица цветов │ │
│ └───────────────────────────┘ │
. . .                       . . .
│ ┌───────────────────────────┐ │    ───┐
│ │   Дескирптор изображения  │ │       │
│ └───────────────────────────┘ │       │
│ ┌───────────────────────────┐ │       │
│ │ Локальная таблица цветов  │ │       ├──  Повторяется
│ └───────────────────────────┘ │       │    от 1 до n раз
│ ┌───────────────────────────┐ │       │
│ │      Растровые данные     │ │       │
│ └───────────────────────────┘ │    ───┘
. . .                       . . .
├─  Терминатор  GIF            ─┤
└───────────────────────────────┘

                              - 4 -

                        ИДЕНТИФИКАТОР GIF

     Наличие в начале  файла специальной "подписи"  указывает, что
последующие   данные   являются   действительно   потоком   данных
изображения  в  формате  GIF.  Эта  "подпись" состоит из следующих
шести символов:
             G I F 8 7 a
Три последних символа '87a' могут рассматриваться как номер версии
для данного конкретного определения  GIF и будут использоваться  в
дальнейшем  в  качестве  ссылки  на  документ  с  описанием  GIF в
зависимости от номера версии.

                        ДЕСКРИПТОР ЭКРАНА

     Дескриптор  экрана   описывает  общие   параметры  для   всех
последующих  изображений  в  формате  GIF.   Он определяет размеры
пространства  изображения  или   требуемого  логического   экрана,
существование информации о таблице цветов и "глубине" экрана.  Эта
информация  запоминается  в  виде  серии  8-битовых  байтов,   как
показано ниже.

              биты
 7 6 5 4 3 2 1 0  Номер байта
┌───────────────┐
│               │  1
├─Ширина экрана─┤      Ширина растра в пикселах (сначала LSB)
│               │  2
├───────────────┤
│               │  3
├─Высота экрана─┤      Высота растра в пикселах (сначала LSB)
│               │  4
├─┬─────┬─┬─────┤      M = 1, За дескриптором следует глобальная
│ │     │ │     │             таблица цветов
│M│  cr │0│pixel│  5   cr+1 = число битов цветового разрешения
├─┴─────┴─┴─────┤      pixel+1 = число бит/пиксел в изображении
│   background  │  6   фон = цветовой индекс фона экрана
├───────────────┤         (цвет определяется из глобальной таблицы
│0 0 0 0 0 0 0 0│  7        цветов или из таблицы по умолчанию)
└───────────────┘

     Значение 'pixel' также определяет число цветов в изображении.
Диапазон значений 'pixel' составляет от 0 до 7, что  соответствует
от 1 до  8 битам. Это  транслируется в диапазон  от 2 (черно-белые
изображения) до 256  цветов.  Бит  3 в байте  5 зарезервирован для
будущих определений и должен быть нулевым.
                              - 5 -
                    ГЛОБАЛЬНАЯ ТАБЛИЦА ЦВЕТОВ

     Глобальная   таблица   цветов   является   необязательной   и
рекомендуется  для  изображений,  где  требуется  точная  передача
цветов. На существование этой таблицы указывает поле 'M' в байте 5
дескриптора экрана.  Цветовая  таблица может быть также  связана с
каждым изображением в GIF-файле, что будет описано позже.   Однако
обычно  эта   глобальная  таблица   будет  использоваться,   из-за
ограничений,   существующих   в   настоящее   время   в  доступном
оборудовании.  Флаг  'M'  в  дескрипторе  конкретного  изображения
обычно равен 0.   Если глобальная таблица цветов  присутствует, ее
определение следует непосредственно за дескриптором экрана.  Число
элементов цветовой таблицы,  следующей за описателем  экрана равно
2**(число  бит/пиксел),  причем  каждый  элемент  состоит  из трех
байтов,  значения  которых  описывают соответственно относительную
интенсивность красного, зеленого и синего цветов. Структура  блока
цветовой таблицы:

      биты
 7 6 5 4 3 2 1 0  Байт #
┌───────────────┐
│интен. красного│  1    Значение красного для цвета 0
├───────────────┤
│интен. зеленого│  2    Значение зеленого для цвета 0
├───────────────┤
│интен. синего  │  3    Значение синего для цвета 0
├───────────────┤
│интен. красного│  4    Значение красного для цвета 1
├───────────────┤
│интен. зеленого│  5    Значение зеленого для цвета 1
├───────────────┤
│интен. синего  │  6    Значение синего для цвета 1
├───────────────┤
:               :       (Продолжение для остальных цветов)

     Получаемое   значение   каждого   пиксела   при  высвечивании
изображения будет соответствовать  ближайшему доступному цвету  из
цветовой таблицы дисплея.  Цветовые компоненты представляют  собой
значение  относительной  интенсивности  от  нулевой  (0) до полной
(255). Белый цвет может быть представлен как (255,255,255), черный
как  (0,0,0)  и  желтый  как  (180,180,0).   При  высвечивании  на
дисплеях, которые поддерживают менее 8 бит на цветовую компоненту,
используются  старшие  биты.   При  создании  элементов   цветовой
таблицы  GIF  на  аппаратуре,   поддерживающей  менее  8  бит   на
компоненту,   значение   аппаратной    компоненты   должно    быть
конвертировано в 8-битный формат по следующей формуле:

   <значение_в_таблице> = <компонента>*255/(2**<число_бит> -1)

     Это обеспечивает точный перевод  цветов для всех дисплеев.  В
случае  создания  изображения  GIF  на  аппаратуре без возможности
цветовой  палитры,  должна  быть  создана фиксированная палитра на
основе  доступных  для  данного  оборудования цветов. Если указано
отсутствие  глобальной  таблицы  цветов,  цветовая  таблица   по
умолчанию генерируется внутренним образом так, что каждый цветовой
индекс равен аппаратному цветовому  индексу modulo <n>, где  <n> -
число доступных цветов на оборудовании.

                             - 6 -

                     ДЕСКРИПТОР ИЗОБРАЖЕНИЯ

     Дескриптор изображения определяет действительное расположение
и   размеры   последующего   изображения   внутри    пространства,
определенного  в  дескрипторе  экрана.   Также определяются флаги,
указывающие на присутствие локальной  таблицы для поиска цветов  и
определения  последовательности  высвечивания  пикселов.    Каждый
дескриптор   изображения    начинается    с    символа-разделителя
изображений.   Роль  разделителя  изображений  состоит  просто   в
синхронизации при входе в дескриптор изображения.  Это желательно,
если  GIF-файл  состоит  более,  чем  из  одного изображения. Этот
символ определен как шестнадцатиричное 0x2C или ',' (запятая). Как
только    этот    символ    встречается    между    изображениями,
непосредственно за ним следует дескриптор изображения.

     Любой   символ,   встреченный   между   концом    предыдущего
изображения и символом-разделителем изображения игнорируется.  Это
позволит при  последующих модификациях  GIF допускать  присутствие
нескольких   форматов   и   правильно   игнорировать   их  старыми
декодерами.

      биты
 7 6 5 4 3 2 1 0  Байт #
┌───────────────┐
│0 0 1 0 1 1 0 0│  1    ',' - Символ-разделитель изображения
├───────────────┤
│               │  2    Начало изображения в пикселах относи-
├─ Левый край  ─┤       тельно левого края экрана (сначала LSB)
│               │  3
├───────────────┤
│               │  4
├─ Верхний край─┤       Начало изображения в пикселах относительно
│               │  5    верхнего края экрана (сначала LSB)
├───────────────┤
│               │  6
├─    Ширина   ─┤       Ширина изображения в пикселах
│               │  7    (сначала LSB)
├───────────────┤
│               │  8
├─    Высота   ─┤       Высота изображения в пикселах
│               │  9    (сначала LSB)
├─┬─┬─┬─┬─┬─────┤       M=0 - Использовать глобальную таблицу цве-
│M│I│0│0│0│pixel│ 10          тов, игнорировать 'pixel'
└─┴─┴─┴─┴─┴─────┘       M=1 - Далее следует локальная таблица цве-
                              тов, использовать 'pixel'
                        I=0 - Изображение отформатировано в после-
                              довательном порядке
                        I=1 - Изображение отформатировано в поряд-
                              ке переплетения
                        pixel+1 - число бит на пиксел в данном
                                  изображении

     Описание положения и  размеров экрана должно  быть находиться
внутри  матрицы,  определенной  в  дескрипторе  экрана.  С  другой
стороны, нет необходимости, чтобы изображение полностью  заполняло
весь экран.

                             - 7 -

                    ЛОКАЛЬНАЯ ТАБЛИЦА ЦВЕТОВ

     Локальная таблица цветов необязательна и определена здесь для
будущего  использования.   Если  установлен  бит  'M'  байта  10 в
дескрипторе  изображения,  то  вслед  за  дескриптором изображения
следует  локальная  таблица  цветов,  которая  относится  только к
последующему изображению.   После обработки  изображения  цветовую
таблицу  следует  привести  к  той,  которая была определена после
дескриптора  экрана.   Заметим,  что  поле  'pixel'  байта  10   в
дескрипторе  изображения  используется  только  в том случае, если
указана локальная таблица цветов.  Она определяет не только размер
пиксела  (число  битов  в  нем),  но  число  элементов последующей
цветовой  таблицы.    Число   битов  на   пиксел  также    следует
восстановить  к   тому  значению,   которое  было   определено   в
дескрипторе  экрана,   после  того,   как  закончится    обработка
изображения.

                        РАСТРОВЫЕ ДАННЫЕ

     Формат  самого  изображения  определен  как  серия   значений
номеров   пикселов,   которые   образуют   изображение.    Пикселы
запоминаются слева направо последовательно по строкам изображения.
По умолчанию строки  записываются последовательно, сверху  вниз. В
том  случае,  если  установлен  бит  'I'  в  байте  10 дескриптора
изображения, то порядок строк при записи изображения соответствует
четырех  проходному  процессу.   При  первом  проходе записывается
каждая 8-ая строка, начиная с верхней строки окна изображения. При
втором проходе  записывается каждая  8-ая строка,  начиная с пятой
строки сверху. На третьем проходе записывается каждая 4-ая строка,
начиная  с  третьей  строки  окна.   Четвертый  проход   завершает
изображение,  записывая  каждую  вторую  строку, начиная со второй
строки  с  сверху.   Ниже  приведено  графическое  описание  этого
процесса.

   Изображение
   Стр. Прох.1  Прох.2  Прох.3  Прох.4          Результат
   ──────────────────────────────────────────────────────
     0  **1a**                                  **1a**
     1                          **4a**          **4a**
     2                  **3a**                  **3a**
     3                          **4b**          **4b**
     4          **2a**                          **2a**
     5                          **4c**          **4c**
     6                  **3b**                  **3b**
     7                          **4d**          **4d**
     8  **1b**                                  **1b**
     9                          **4e**          **4e**
    10                  **3c**                  **3c**
    11                          **4f**          **4f**
    12          **2b**                          **2b**
   . . .

     Значения  пикселов  изображения  обрабатываются  как цветовые
индексы, указывающие на существующую таблицу цветов. В  результате
получается  цветовое   значение  из   таблицы,  которое    реально
воспроизводится  на  экране.  Эти  серии  цветовых индексов, число
которых равно ширине_изображения*высоту_изображения,  пропускаются
через поток данных изображения  GIF по одному значению  на пиксел,
сжимаются  и  упаковываются  в  соответствии  с  версией алгоритма
сжатия LZW, как это определено в Приложении C.

                             - 8 -

                         ТЕРМИНАТОР GIF

     Для того, чтобы  обеспечить синхронизацию с  окончанием файла
изображения GIF, декодер GIF должен обрабатывать окончание  режима
GIF по  символу шестнадцатиричное  0x3B или  ';', найденному после
окончания  обработки  изображения.   По  соглашению   декодирующие
программы должны делать паузу  и ждать действий, указывающих,  что
пользователь готов к продолжению. Это может быть возврат  каретки,
введенный с клавиатуры или щелчок кнопкой мыши. Для  интерактивных
приложений эти действия пользователя  должны быть переданы в  ядро
программы  как  перевод  каретки,  для  того, чтобы вычислительный
процесс мог продолжаться.  Обычно декодирующая программа  покидает
графический режим и возвращается к предыдущему процессу.

                      РАСШИРЕННЫЙ БЛОК GIF

     Для того, чтобы обеспечить аккуратное расширение  определения
GIF,  необходим  механизм  для  определения упаковки внутри потока
данных GIF. Указанное расширение было определено и документировано
CompuServe  для  того,  чтобы  предусмотреть  управляемый   способ
усовершенствований.

     Расширенный  блок  GIF  пакуется  способом,  похожим  на тот,
который  использовался  для  растровых  данных,  но  не сжимается.
Основная структура блока:

 7 6 5 4 3 2 1 0  Байт #
┌───────────────┐
│0 0 1 0 0 0 0 1│  1       '!' - Идентификатор расширенного блока
├───────────────┤
│ функц. код    │  2       Расширенный функциональный код (0-255)
├───────────────┤    ───┐
│ байт-счетчик  │       │
├───────────────┤       │
│               │       ├── Повторяется столько раз, сколько
│  функ. байты  │       │   необходимо
│   данных      │       │
├───────────────┤    ───┘
. . .       . . .
├───────────────┤
│0 0 0 0 0 0 0 0│       нулевой байт-счетчик (терминатор блока)
└───────────────┘

     Расширенный  блок  GIF  может  непосредственно предшествовать
дескриптору изображения или находиться перед терминатором GIF.

     Все   декодеры   GIF   должны   быть   способны  распознавать
присутствие расширенного блока GIF и затем читать его, если они не
могут обработать функциональный  код. Это гарантирует,  что старые
декодеры смогут обрабатывать файлы изображений GIF в будущем, хотя
и без дополнительных функциональных возможностей.
                             - 11 -
                          ПРИЛОЖЕНИЕ C

                  СЖАТИЕ И УПАКОВКА ИЗОБРАЖЕНИЯ

     Поток  растровых  данных,  которые  описывают  действительное
выходное изображение может быть представлен в следующем виде:

 7 6 5 4 3 2 1 0
┌───────────────┐
│  код размера  │
├───────────────┤     ───┐
│ байт-счетчик  │        │
│    блока      │        │
├───────────────┤        │
│               │        ├── Повторяется столько раз, сколько
│  байт данных  │        │   необходимо
│               │        │
├───────────────┤     ───┘
. . .       . . .
├───────────────┤
│0 0 0 0 0 0 0 0│    нулевой байт-счетчик
└───────────────┘    (заканчивает поток данных)

     Преобразование  изображения  из  серии  значений  пикселов  к
передаваемому или запоминаемому потоку символов включает несколько
шагов. Вкратце эти шаги состоят в следующем:

1.  Установка кода размера -  Определяет число битов,  необходимое
    для представления действительных данных.

2.  Сжатие данных  - Сжатие  серии пикселов  изображения в   серию
    кодов сжатия.

3.  Построение  серии  байтов  -  берет  серию  кодов  сжатия    и
    преобразует их в строку 8-битных данных.

4.  Упаковка байтов  - Упаковка  набора байтов  в блоки,   которым
    предшествует символ-счетчик и вывод.

                     УСТАНОВКА КОДА РАЗМЕРА

     Первый байт  в потоке  растровых данных  GIF имеет  значение,
указывающее минимальное число битов, необходимое для представления
для представления  действительных значений  пикселов. Как  правило
оно  будет  таким  же,  что  и  число  битов  цвета.  Однако из-за
некоторых ограничений  алгоритма черно-белые  изображения, которые
имеют один бит  цвета, должны иметь  код размера, равный  2. Такое
значение кода размера подразумевает также, что коды сжатия  должны
быть на один бит длиннее.

                             СЖАТИЕ

     Алгоритм LZW преобразует серию значений данных в серию кодов,
которые  могут  быть  самими  значениями  или кодами, описывающими
серию значений. Если использовать аналогию с текстовыми символами,
то выходные коды  состоят из символов  и кодов, которые  описывают
цепочки символов.

                             - 13 -
     LZW-алгоритм,    использованный    в    GIF    алгоритмически
соответствует стандартному алгоритму LZW со следующими отличиями:

1.  Определен  специальный  код  очистки,  который сбрасывает  все
    параметры  сжатия/раскрытия  и  таблицы  в исходное состояние.
    Значение этого кода равно 2**<код размера>. Например, если код
    размера  равен  4  (изображение  имеет  4 бита на пиксел), код
    очистки  равен  16  (двоичное   10000).   Код  очистки   может
    появляться  в  любом  месте  потока  данных  и, следовательно,
    требуется,  чтобы  LZW-алгоритм  обрабатывал  последующие коды
    так,  как  будто  бы  начался  новый  поток данных. Кодировщик
    должен выводить код очистки  в качестве первого кода  в каждом
    потоке данных изображения.

2.  Определен  код  конца  информации,  который явно указывает  на
    конец потока  данных изображения.  Если встретится  такой код,
    LZW-обработка  прекращается.  Этот  код  должен быть последним
    кодом,  формируемым  кодировщиком  для  изображения.  Значение
    этого кода равно <Код_очистки>+1.

3.  Значение первого доступного кода сжатия равно <Код_очистки>+2.

4.  Выходные   коды   имеют    переменную   длину,   начиная    от
    <код_размера>+1 битов на  код, до 12  битов на код.  Тем самым
    максимальное   значение   кода   определяется   равным    4095
    (шестнадцатиричное FFF).  Как только  значение LZW-кода  может
    превысить  текущую  длину  кода,  длина  кода увеличивается на
    единицу. Паковщик и распаковщик этих кодов должны  изменяться,
    чтобы соответствовать новой длине кода.

                   ПОСТРОЕНИЕ 8-БИТНЫХ БАЙТОВ

     Поскольку  LZW-сжатие,  используемое  для  GIF, создает серию
кодов переменной длины от 3 до 12 символов каждый, эти коды должны
быть переформированы в серию  8-битный байтов так, чтобы  на самом
деле   происходило   запоминание   или   передача   символов.  Это
обеспечивает дополнительное сжатие изображения. Коды формируются в
поток битов так, как если бы они паковались справа налево, и затем
выбираются по 8 битов для вывода. Рассматриваемый массив  8-битных
символов при упаковке кодов длиной по 5 битов должен быть похож на
следующий пример:

      байт n       байт 5   байт 4   байт 3   байт 2   байт 1
     ┌─.....─────+────────+────────+────────+────────+────────┐
     │ and so on │hhhhhggg│ggfffffe│eeeedddd│dcccccbb│bbbaaaaa│
     └─.....─────+────────+────────+────────+────────+────────┘

     Заметьте, что механизм  физической упаковки будет  изменяться
по  мере  того,  как  изменяется  число  битов  в  коде сжатия, но
концептуально он остается тем же самым.

                             - 14 -

                         УПАКОВКА БАЙТОВ

     Как  только  байты  созданы,  они  группируются  в  блоки для
вывода,  причем   каждому  блоку   предшествует  байт-счетчик   со
значением от 0 до 255. Блок с нулевым байтом-счетчиком заканчивает
поток данных для данного изображения. Эти блоки являются тем,  что
выводится  на  самом  деле  в  формате  GIF.  Такой  формат  блока
обеспечивает  дополнительную  эффективность  за  счет  того,   что
позволяет декодировщику  считывать данные  по мере  необходимости,
читая  сначала  байт-счетчик,  а  затем  пропуская  сами данные об
изображении.


                        *** ФОРМАТ TIFF ФАЙЛОВ ***
   Возможно, это самый динамичный и перспективный из ныне существующих
графических форматов.
   Поддерживает:
  1. различный порядок байтов в словах и двойных словах - Intel, Motorola
  2. хранение нескольких картинок в одном файле
  3. классы изображений - с палитрой, TrueColor, GrayScaled ,монохромные
бит/пиксел - 1,4,8,24, а так-же Любые Другие значения, причём для TrueColor
  4. существует возможность (пока официально не разрешённая ) использования разных значений бит/пиксел для каждой из RGB составляющих.
сжатие растровых данных - PackBit (RLE), LZW, а так-же несколько алгоритмов,
предназначенных для сжатия факсимильных сообщений и основанных на алгоритме
Huffmanа.

                      Внутренняя структура:
   В начале файла находится заголовок, содержащий информацию об очерёдности
байтов в словах и двойных словах, используемой в данном файле, а так-же
поле, указывающее на  положение первого (и часто единственного) IFD (см.
далее).  Поддержка возможности хранения нескольких картинок в одном файле
реализована следующим образом: для каждой картинки в файле существует
специальный блок данных - Image File Directory ( IFD ), полностью описывающий
параметры соответствующей картинкив произвольных местах и организованы в
односвязный список - в каждом IFD есть поле связи, содержащее
положение следующего IFD, либо признакпоследнего IFD (ноль).

   На положение первого (и часто единственного)
IFD указывает специальное поле в заголовке файла.
   Каждый из IFD представляет собой набор одинаковых структур, называемых
ТЭГ (каждая из которых описывает какую-либо одну характеристику картинки),
плюс информация об их (ТЭГов) количестве и положении следующего IFD.
Существует большое количество определённых типов ТЭГ, и не обязательно
все возможные ТЭГ должны содержаться в IFD.
С другой стороны, в IFD должен содержаться некий минимальный набор ТЭГов,
без которых производить какие либо операции с картинкой просто невозможно
(например всегда должен присутствовать ТЭГ, содержащий ширину картинки ).
Несколько выправить положениепомогает то, что если какой - нибуть ТЭГ
отсутствует в IFD, но нуженсчитывающей программе,
то эта программа должна подставить указанное вспецификации значение по
умолчанию для данного ТЭГ (разумеется, значениепо умолчанию определено
не для всех ТЭГов).
   Структура ТЭГ описывает какую-либо одну характеристику картинки (высота,
ширина, число бит/пиксел и т.д.) и содержит следующие поля:
   Тип (он же тэг) - самое важное поле, идентифицирующее конкетную
характеристику изображения, описываемую остальными
частями структуры. Тип Данных - связан с размером хранимой единицы
информации (может принимать значения  Byte, Short, Long, etc...).
Длина Поля Данных - количество хранимых единиц информации. Если
размер-единицы-информации * длина-поля-данных больше,
чем 4 байта, то следующее поле содержит ссылку на место в файле, где
хранятся данные (это справедливо для массивов и ASCII строк).
В противном случае следующее поле содержит непосредственно данные.
Значение - содержит ссылку на место в файле, где хранятся данные
(это справедливо для массивов и ASCII строк), либо содержит
непосредственно данные.

         ********* ЗНАЧЕНИЯ ТЕГОВ *************
NewSubfileType     equ 254
;(FE)
;Type    = LONG
;N       = 1

SubfileType     equ 255
;(FF)
;Type    = SHORT
;N       = 1

ImageWidth     equ 256
;(100)
;Type    = SHORT
;N       = 1

ImageLength     equ 257
;(101)
;Type    = SHORT
;N       = 1

BitsPerSample     equ 258
;(102)
;Type    = SHORT
;N       = SamplesPerPixel

Compression     equ 259
;(103)
;Type    = SHORT
;N       = SamplesPerPixel for PlanarConfiguration equal to 1 or 2.

PhotometricInterpretation     equ 262
;(106)
;Type    = SHORT
;N       = 1

Threshholding     equ 263
;(107)
;Type    = SHORT
;N       = 1

CellWidth     equ 264
;(108)
;Type    = SHORT
;N       = 1

CellLength     equ 265
;(109)
;Type    = SHORT
;N       = 1

FillOrder     equ 266
;(10A)
;Type    = SHORT
;N       = 1

DocumentName     equ 269
;(10D)
;Type    = ASCII

ImageDescription     equ 270
;(10E)
;Type    = ASCII

Make     equ 271
;(10F)
;Type    = ASCII

Model     equ 272
;(110)
;Type    = ASCII

StripOffsets     equ 273
;(111)
;Type    = SHORT or LONG
;N       = StripsPerImage for PlanarConfiguration equal to 1.
;        = SamplesPerPixel * StripsPerImage for PlanarConfiguration equal to 2

Orientation     equ 274
;(112)
;Type    = SHORT
;N               = 1

SamplesPerPixel     equ 277
;(115)
;Type    = SHORT
;N       = 1

RowsPerStrip     equ 278
;(116)
;Type    = SHORT or LONG
;N       = 1

StripByteCounts     equ 279
;(117)
;Type    = LONG
;N       = StripsPerImage for PlanarConfiguration equal to 1.
;        = SamplesPerPixel * StripsPerImage for PlanarConfiguration equal to 2

MinSampleValue     equ 280
;(118)
;Type    = SHORT
;N       = SamplesPerPixel

MaxSampleValue     equ 281
;(119)
;Type    = SHORT
;N       = SamplesPerPixel

XResolution     equ 282
;(11A)
;Type    = RATIONAL
;N       = 1

YResolution     equ 283
;(11B)
;Type    = RATIONAL
;N       = 1

PlanarConfiguration     equ 284
;(11C)
;Type    = SHORT
;N       = 1

PageName     equ 285
;(11D)
;Type    = ASCII

XPosition     equ 286
;(11E)
;Type    = RATIONAL

YPosition     equ 287
;(11F)
;Type    = RATIONAL

FreeOffsets     equ 288
;(120)
;Type    = LONG

FreeByteCounts     equ 289
;(121)
;Type    = LONG

GrayResponseUnit     equ 290
;(122)
;Type    = SHORT
;N       = 1

GrayResponseCurve     equ 291
;(123)
;Type    = SHORT
;N       = 2**BitsPerSample

Group3Options     equ 292
;(124)
;Type    = LONG
;N       = 1

Group4Options     equ  293
;(125)
;Type    = LONG
;N       = 1

ResolutionUnit     equ 296
;(128)
;Type    = SHORT
;N       = 1

PageNumber     equ 297
;(129)
;Type    = SHORT
;N       = 2

ColorResponseUnit     equ 300
;(12C)
;Type    = SHORT
;N       = 1

ColorResponseCurves     equ 301
;(12D)
;Type    = SHORT
;N       = 2**BitsPerSample (for Red sample)+
;                2**BitsPerSample (for Green sample)+
;                2**BitsPerSample(for Blue sample)

Software        equ     305
;(131)
;Type   = ASCII

DateTime        equ     306
;(132)
;Type   = ASCII

Artist  equ     315
;(13b)
;Type   = ASCII

HostComputer    equ     316
;(13c)
;Type   = ASCII

Predictor       equ     317
;(13d)
;Type   = SHORT
;N      = 1
;1 = no prediction scheme used before coding
;2 = Horisontal differencing (see tiff.prn file)

ColorImageType  =       318
;(13e)
;type   = SHORT
;N      = 1

ColorList       =       319
;(13f)
;type   = BYTE or SHORT
;N      = number of colors that are used in image * SamplesPerPixel

ColorMap        equ     320
;(140)
;Type   = SHORT
;N      = 3*(2**BitPerPixel)
