

               Отчет по форматам файлов BMP и GIF
            подготовил студент 542 группы Фелингер К.В.


                           Оглавление

        ФОРМАТ ВМР - СТРУКТУРА BMP-ФАЙЛА . . . . . . . . . 2
        ФОРМАТ GIF . . . . . . . . . . . . . . . . . . . . 3
          ОБЩИЙ ФОРМАТ ФАЙЛА . . . . . . . . . . . . . . . 3
          ИДЕНТИФИКАТОР GIF. . . . . . . . . . . . . . . . 4
          ДЕСКРИПТОР ЭКРАНА. . . . . . . . . . . . . . . . 4
          ГЛОБАЛЬНАЯ ТАБЛИЦА ЦВЕТОВ. . . . . . . . . . . . 5
          ДЕСКРИПТОР ИЗОБРАЖЕНИЯ . . . . . . . . . . . . . 6
          ЛОКАЛЬНАЯ ТАБЛИЦА ЦВЕТОВ . . . . . . . . . . . . 7
          РАСТРОВЫЕ ДАННЫЕ . . . . . . . . . . . . . . . . 7
          ТЕРМИНАТОР GIF . . . . . . . . . . . . . . . . . 8
          РАСШИРЕННЫЙ БЛОК GIF . . . . . . . . . . . . . . 8
          ПРИЛОЖЕНИЕ A - ГЛОССАРИЙ . . . . . . . . . . . . 9
          ПРИЛОЖЕНИЕ B - ВЗАИМОДЕЙСТВУЮЩИЕ
                        ПОСЛЕДОВАТЕЛЬНОСТИ. . . . . . . . .10
          ПРИЛОЖЕНИЕ C - УПАКОВКА И СЖАТИЕ ИЗОБРАЖЕНИЯ. . .12
          ПРИЛОЖЕНИЕ D - ОБРАБОТКА НЕСКОЛЬКИХ ИЗОБРАЖЕНИЙ .15
          ПРИЛОЖЕНИЕ Е - ОБЪЯСНЕНИЕ LZW И GIF . . . . . . .16


                              - 2 -

                    ФОРМАТ ВМР -  СТРУКТУРА BMP-ФАЙЛА

         BMP- один из форматов файлов WINDOWS,используется для хранения гра-
   фических изображений в виде битовой карты,что собственно видно из названия
   (BITMAP).Общая структура bmp-файла :
  ┌────────────────────────┐
  │ BITMAP_FILE -заголовок │
  ├────────────────────────┤
  │ BMP_INFO               │
  │ BMP_INFO-заголовок     │
  │ RGB_QUAD               │
  ├────────────────────────┤
  │ BMP-данные             │
  └────────────────────────┘

    Структура заголовка bmp-файла :

                             BITMAP_FILE
 ┌──────────┬────────────────┬───────────┬─────────────────────────────┐
 │ Смещение │ длина в байтах │    Имя    │           Значение          │
 ├──────────┼────────────────┼───────────┼─────────────────────────────┤
 │   00h    │      2         │  bfType   │  Метка 'BM'                 │
 ├──────────┼────────────────┼───────────┼─────────────────────────────┤
 │   02h    │      4         │  bfSize   │  длина файла в байтах       │
 ├──────────┼────────────────┼───────────┼─────────────────────────────┤
 │   06h    │      2         │     -     │  резерв,должны содержать 0  │
 ├──────────┼────────────────┼───────────┼─────────────────────────────┤
 │   08h    │      2         │     -     │      -!!-                   │
 ├──────────┼────────────────┼───────────┼─────────────────────────────┤
 │   0Ah    │      4         │  bfOffs   │  смещение области данных    │
 └──────────┴────────────────┴───────────┴─────────────────────────────┘

       В блоке INFO описываются параметры изображения :
 ┌──────────┬────────────────┬────────────┬───────────────────────────────────┐
 │ Смещение │ длина в байтах │    Имя     │         Значение                  │
 ├──────────┼────────────────┼────────────┼───────────────────────────────────┤
 │          │                │            │ BITMAP_INFO-заголовок             │
 ├──────────┼────────────────┼────────────┼───────────────────────────────────┤
 │   0Eh    │       4        │  biSize    │ длина заголовка в байтах          │
 ├──────────┼────────────────┼────────────┼───────────────────────────────────┤
 │   12h    │       4        │  biWidth   │ ширина битовой карты в пикселах   │
 ├──────────┼────────────────┼────────────┼───────────────────────────────────┤
 │   16h    │       4        │  biHeight  │ высота битовой карты в пикселах   │
 ├──────────┼────────────────┼────────────┼───────────────────────────────────┤
 │   1Ah    │       2        │  biPlanes  │ цветовые плоскости                │
 ├──────────┼────────────────┼────────────┼───────────────────────────────────┤
 │   1Ch    │       2        │  biBitCnt  │ количество битов на пиксел        │
 ├──────────┼────────────────┼────────────┼───────────────────────────────────┤
 │   1Eh    │       4        │  biCompr   │ тип сжатия данных                 │
 ├──────────┼────────────────┼────────────┼───────────────────────────────────┤
 │   22h    │       4        │  biSizeIm  │ размер гр.изобр. в байтах         │
 ├──────────┼────────────────┼────────────┼───────────────────────────────────┤
 │   26h    │       4        │  biXPels/m │ разрешение по горизонтали         │
 ├──────────┼────────────────┼────────────┼───────────────────────────────────┤
 │   2Ah    │       4        │  biYPels/m │ разрешение по вертикали           │
 ├──────────┼────────────────┼────────────┼───────────────────────────────────┤
 │   2Eh    │       4        │  biClrUsed │ количество используемых цветов    │
 ├──────────┼────────────────┼────────────┼───────────────────────────────────┤
 │   32h    │       4        │  biClrImp  │ кол-во основных цветов            │
 ├──────────┼────────────────┼────────────┼───────────────────────────────────┤
 │          │                │            │ RGB_QUAD                          │
 ├──────────┼────────────────┼────────────┼───────────────────────────────────┤
 │   36h    │      n*4       │            │ Опр-е для n цветов с раскладкой   │
 │          │                │            │                                   │
 │          │                │  rgb Blue  │ 1-байт-интенсивность голубого     │
 │          │                │            │                                   │
 │          │                │  rgb Green │ 1-байт- -!!-         зеленого     │
 │          │                │            │                                   │
 │          │                │  rgb Red   │ 1-байт- -!!-         красного     │
 │          │                │            │                                   │
 │          │                │  rgb res   │ 1-байт-резервный                  │
 └──────────┴────────────────┴────────────┴───────────────────────────────────┘
   Далее следует область данных графического изображения построчно,начиная с
   левого нижнего угла.

                              - 3 -

                            ФОРМАТ GIF

                Graphics Interchange Format (tm)
                  (Формат графического обмена)

           Описание формата графического обмена (GIF)


     'GIF' (tm)  - это  стандарт фирмы  CompuServe для определения
растровых цветных изображений.  Этот формат позволяет  высвечивать
на   различном    оборудовании   графические    высококачественные
изображения с большим разрешением и подразумевает механизм  обмена
и высвечивания изображений. Описанный в настоящем документе формат
изображений  был  разработан  для  поддержки  настоящей  и будущей
технологии  обработки  изображений  и  будет  в дальнейшем служить
основой для будущих графических продуктов CompuServe.

     Главная  задача  настоящего  документа  состоит  в том, чтобы
снабдить  программистов  необходимой  технической  информацией для
написания  декодеров  и  кодировщиков  GIF.  Поэтому  в  документе
используется терминология связанная  с общими вопросами  графики и
программирования.

     Первый раздел  настоящего документа  описывает формат  данных
GIF и его компоненты в приложении к декодерам GIF, вне зависимости
от того  являются ли  они отдельной  программой или  частью пакета
связи.   Приложение  B  относится  к  декодерам являющимися частью
пакетов  связи  и  описывает  протокол,  необходимый  для  входа и
существования режима GIF и отвечает на ряд специфических вопросов.
Глоссарий   в   приложении   A   определяет   некоторые   термины,
использованные в документе. Приложение C дает подробное объяснение
того,   как   сами   графические   изображения   пакуются  в  виде
последовательности байтов.

                 Определение формата данных GIF

                       ОБЩИЙ ФОРМАТ ФАЙЛА

┌───────────────────────────────┐
│ ┌───────────────────────────┐ │
│ │     Идентификатор GIF     │ │
│ └───────────────────────────┘ │
│ ┌───────────────────────────┐ │
│ │      Дескриптор экрана    │ │
│ └───────────────────────────┘ │
│ ┌───────────────────────────┐ │
│ │ Глобальная таблица цветов │ │
│ └───────────────────────────┘ │
. . .                       . . .
│ ┌───────────────────────────┐ │    ───┐
│ │   Дескирптор изображения  │ │       │
│ └───────────────────────────┘ │       │
│ ┌───────────────────────────┐ │       │
│ │ Локальная таблица цветов  │ │       ├──  Повторяется
│ └───────────────────────────┘ │       │    от 1 до n раз
│ ┌───────────────────────────┐ │       │
│ │      Растровые данные     │ │       │
│ └───────────────────────────┘ │    ───┘
. . .                       . . .
├─  Терминатор  GIF            ─┤
└───────────────────────────────┘

                              - 4 -

                        ИДЕНТИФИКАТОР GIF

     Наличие в начале  файла специальной "подписи"  указывает, что
последующие   данные   являются   действительно   потоком   данных
изображения  в  формате  GIF.  Эта  "подпись" состоит из следующих
шести символов:
             G I F 8 7 a
Три последних символа '87a' могут рассматриваться как номер версии
для данного конкретного определения  GIF и будут использоваться  в
дальнейшем  в  качестве  ссылки  на  документ  с  описанием  GIF в
зависимости от номера версии.

                        ДЕСКРИПТОР ЭКРАНА

     Дескриптор  экрана   описывает  общие   параметры  для   всех
последующих  изображений  в  формате  GIF.   Он определяет размеры
пространства  изображения  или   требуемого  логического   экрана,
существование информации о таблице цветов и "глубине" экрана.  Эта
информация  запоминается  в  виде  серии  8-битовых  байтов,   как
показано ниже.

              биты
 7 6 5 4 3 2 1 0  Номер байта
┌───────────────┐
│               │  1
├─Ширина экрана─┤      Ширина растра в пикселах (сначала LSB)
│               │  2
├───────────────┤
│               │  3
├─Высота экрана─┤      Высота растра в пикселах (сначала LSB)
│               │  4
├─┬─────┬─┬─────┤      M = 1, За дескриптором следует глобальная
│ │     │ │     │             таблица цветов
│M│  cr │0│pixel│  5   cr+1 = число битов цветового разрешения
├─┴─────┴─┴─────┤      pixel+1 = число бит/пиксел в изображении
│   background  │  6   фон = цветовой индекс фона экрана
├───────────────┤         (цвет определяется из глобальной таблицы
│0 0 0 0 0 0 0 0│  7        цветов или из таблицы по умолчанию)
└───────────────┘

     Ширина и высота логического экрана могут быть больше размеров
физического экрана. Способ  высвечивания изображений больших,  чем
размеры  физического   экрана  зависит   от  реализации   и  может
использовать преимущества конкретного оборудования (например, окна
скроллинга  в  Macintosh  scrolling  windows).  В противном случае
изображение будет усечено по краям экрана.

     Значение 'pixel' также определяет число цветов в изображении.
Диапазон значений 'pixel' составляет от 0 до 7, что  соответствует
от 1 до  8 битам. Это  транслируется в диапазон  от 2 (черно-белые
изображения) до 256  цветов.  Бит  3 в байте  5 зарезервирован для
будущих определений и должен быть нулевым.

                              - 5 -

                    ГЛОБАЛЬНАЯ ТАБЛИЦА ЦВЕТОВ

     Глобальная   таблица   цветов   является   необязательной   и
рекомендуется  для  изображений,  где  требуется  точная  передача
цветов. На существование этой таблицы указывает поле 'M' в байте 5
дескриптора экрана.  Цветовая  таблица может быть также  связана с
каждым изображением в GIF-файле, что будет описано позже.   Однако
обычно  эта   глобальная  таблица   будет  использоваться,   из-за
ограничений,   существующих   в   настоящее   время   в  доступном
оборудовании.  Флаг  'M'  в  дескрипторе  конкретного  изображения
обычно равен 0.   Если глобальная таблица цветов  присутствует, ее
определение следует непосредственно за дескриптором экрана.  Число
элементов цветовой таблицы,  следующей за описателем  экрана равно
2**(число  бит/пиксел),  причем  каждый  элемент  состоит  из трех
байтов,  значения  которых  описывают соответственно относительную
интенсивность красного, зеленого и синего цветов. Структура  блока
цветовой таблицы:

      биты
 7 6 5 4 3 2 1 0  Байт #
┌───────────────┐
│интен. красного│  1    Значение красного для цвета 0
├───────────────┤
│интен. зеленого│  2    Значение зеленого для цвета 0
├───────────────┤
│интен. синего  │  3    Значение синего для цвета 0
├───────────────┤
│интен. красного│  4    Значение красного для цвета 1
├───────────────┤
│интен. зеленого│  5    Значение зеленого для цвета 1
├───────────────┤
│интен. синего  │  6    Значение синего для цвета 1
├───────────────┤
:               :       (Продолжение для остальных цветов)

     Получаемое   значение   каждого   пиксела   при  высвечивании
изображения будет соответствовать  ближайшему доступному цвету  из
цветовой таблицы дисплея.  Цветовые компоненты представляют  собой
значение  относительной  интенсивности  от  нулевой  (0) до полной
(255). Белый цвет может быть представлен как (255,255,255), черный
как  (0,0,0)  и  желтый  как  (180,180,0).   При  высвечивании  на
дисплеях, которые поддерживают менее 8 бит на цветовую компоненту,
используются  старшие  биты.   При  создании  элементов   цветовой
таблицы  GIF  на  аппаратуре,   поддерживающей  менее  8  бит   на
компоненту,   значение   аппаратной    компоненты   должно    быть
конвертировано в 8-битный формат по следующей формуле:

   <значение_в_таблице> = <компонента>*255/(2**<число_бит> -1)

     Это обеспечивает точный перевод  цветов для всех дисплеев.  В
случае  создания  изображения  GIF  на  аппаратуре без возможности
цветовой  палитры,  должна  быть  создана фиксированная палитра на
основе  доступных  для  данного  оборудования цветов. Если указано
отсутствие  глобальной  таблицы  цветов,  цветовая  таблица   по
умолчанию генерируется внутренним образом так, что каждый цветовой
индекс равен аппаратному цветовому  индексу modulo <n>, где  <n> -
число доступных цветов на оборудовании.

                             - 6 -

                     ДЕСКРИПТОР ИЗОБРАЖЕНИЯ

     Дескриптор изображения определяет действительное расположение
и   размеры   последующего   изображения   внутри    пространства,
определенного  в  дескрипторе  экрана.   Также определяются флаги,
указывающие на присутствие локальной  таблицы для поиска цветов  и
определения  последовательности  высвечивания  пикселов.    Каждый
дескриптор   изображения    начинается    с    символа-разделителя
изображений.   Роль  разделителя  изображений  состоит  просто   в
синхронизации при входе в дескриптор изображения.  Это желательно,
если  GIF-файл  состоит  более,  чем  из  одного изображения. Этот
символ определен как шестнадцатиричное 0x2C или ',' (запятая). Как
только    этот    символ    встречается    между    изображениями,
непосредственно за ним следует дескриптор изображения.

     Любой   символ,   встреченный   между   концом    предыдущего
изображения и символом-разделителем изображения игнорируется.  Это
позволит при  последующих модификациях  GIF допускать  присутствие
нескольких   форматов   и   правильно   игнорировать   их  старыми
декодерами.

      биты
 7 6 5 4 3 2 1 0  Байт #
┌───────────────┐
│0 0 1 0 1 1 0 0│  1    ',' - Символ-разделитель изображения
├───────────────┤
│               │  2    Начало изображения в пикселах относи-
├─ Левый край  ─┤       тельно левого края экрана (сначала LSB)
│               │  3
├───────────────┤
│               │  4
├─ Верхний край─┤       Начало изображения в пикселах относительно
│               │  5    верхнего края экрана (сначала LSB)
├───────────────┤
│               │  6
├─    Ширина   ─┤       Ширина изображения в пикселах
│               │  7    (сначала LSB)
├───────────────┤
│               │  8
├─    Высота   ─┤       Высота изображения в пикселах
│               │  9    (сначала LSB)
├─┬─┬─┬─┬─┬─────┤       M=0 - Использовать глобальную таблицу цве-
│M│I│0│0│0│pixel│ 10          тов, игнорировать 'pixel'
└─┴─┴─┴─┴─┴─────┘       M=1 - Далее следует локальная таблица цве-
                              тов, использовать 'pixel'
                        I=0 - Изображение отформатировано в после-
                              довательном порядке
                        I=1 - Изображение отформатировано в поряд-
                              ке переплетения
                        pixel+1 - число бит на пиксел в данном
                                  изображении

     Описание положения и  размеров экрана должно  быть находиться
внутри  матрицы,  определенной  в  дескрипторе  экрана.  С  другой
стороны, нет необходимости, чтобы изображение полностью  заполняло
весь экран.

                             - 7 -

                    ЛОКАЛЬНАЯ ТАБЛИЦА ЦВЕТОВ

     Локальная таблица цветов необязательна и определена здесь для
будущего  использования.   Если  установлен  бит  'M'  байта  10 в
дескрипторе  изображения,  то  вслед  за  дескриптором изображения
следует  локальная  таблица  цветов,  которая  относится  только к
последующему изображению.   После обработки  изображения  цветовую
таблицу  следует  привести  к  той,  которая была определена после
дескриптора  экрана.   Заметим,  что  поле  'pixel'  байта  10   в
дескрипторе  изображения  используется  только  в том случае, если
указана локальная таблица цветов.  Она определяет не только размер
пиксела  (число  битов  в  нем),  но  число  элементов последующей
цветовой  таблицы.    Число   битов  на   пиксел  также    следует
восстановить  к   тому  значению,   которое  было   определено   в
дескрипторе  экрана,   после  того,   как  закончится    обработка
изображения.

                        РАСТРОВЫЕ ДАННЫЕ

     Формат  самого  изображения  определен  как  серия   значений
номеров   пикселов,   которые   образуют   изображение.    Пикселы
запоминаются слева направо последовательно по строкам изображения.
По умолчанию строки  записываются последовательно, сверху  вниз. В
том  случае,  если  установлен  бит  'I'  в  байте  10 дескриптора
изображения, то порядок строк при записи изображения соответствует
четырех  проходному  процессу.   При  первом  проходе записывается
каждая 8-ая строка, начиная с верхней строки окна изображения. При
втором проходе  записывается каждая  8-ая строка,  начиная с пятой
строки сверху. На третьем проходе записывается каждая 4-ая строка,
начиная  с  третьей  строки  окна.   Четвертый  проход   завершает
изображение,  записывая  каждую  вторую  строку, начиная со второй
строки  с  сверху.   Ниже  приведено  графическое  описание  этого
процесса.

   Изображение
   Стр. Прох.1  Прох.2  Прох.3  Прох.4          Результат
   ──────────────────────────────────────────────────────
     0  **1a**                                  **1a**
     1                          **4a**          **4a**
     2                  **3a**                  **3a**
     3                          **4b**          **4b**
     4          **2a**                          **2a**
     5                          **4c**          **4c**
     6                  **3b**                  **3b**
     7                          **4d**          **4d**
     8  **1b**                                  **1b**
     9                          **4e**          **4e**
    10                  **3c**                  **3c**
    11                          **4f**          **4f**
    12          **2b**                          **2b**
   . . .

     Значения  пикселов  изображения  обрабатываются  как цветовые
индексы, указывающие на существующую таблицу цветов. В  результате
получается  цветовое   значение  из   таблицы,  которое    реально
воспроизводится  на  экране.  Эти  серии  цветовых индексов, число
которых равно ширине_изображения*высоту_изображения,  пропускаются
через поток данных изображения  GIF по одному значению  на пиксел,
сжимаются  и  упаковываются  в  соответствии  с  версией алгоритма
сжатия LZW, как это определено в Приложении C.

                             - 8 -

                         ТЕРМИНАТОР GIF

     Для того, чтобы  обеспечить синхронизацию с  окончанием файла
изображения GIF, декодер GIF должен обрабатывать окончание  режима
GIF по  символу шестнадцатиричное  0x3B или  ';', найденному после
окончания  обработки  изображения.   По  соглашению   декодирующие
программы должны делать паузу  и ждать действий, указывающих,  что
пользователь готов к продолжению. Это может быть возврат  каретки,
введенный с клавиатуры или щелчок кнопкой мыши. Для  интерактивных
приложений эти действия пользователя  должны быть переданы в  ядро
программы  как  перевод  каретки,  для  того, чтобы вычислительный
процесс мог продолжаться.  Обычно декодирующая программа  покидает
графический режим и возвращается к предыдущему процессу.

                      РАСШИРЕННЫЙ БЛОК GIF

     Для того, чтобы обеспечить аккуратное расширение  определения
GIF,  необходим  механизм  для  определения упаковки внутри потока
данных GIF. Указанное расширение было определено и документировано
CompuServe  для  того,  чтобы  предусмотреть  управляемый   способ
усовершенствований.

     Расширенный  блок  GIF  пакуется  способом,  похожим  на тот,
который  использовался  для  растровых  данных,  но  не сжимается.
Основная структура блока:

 7 6 5 4 3 2 1 0  Байт #
┌───────────────┐
│0 0 1 0 0 0 0 1│  1       '!' - Идентификатор расширенного блока
├───────────────┤
│ функц. код    │  2       Расширенный функциональный код (0-255)
├───────────────┤    ───┐
│ байт-счетчик  │       │
├───────────────┤       │
│               │       ├── Повторяется столько раз, сколько
│  функ. байты  │       │   необходимо
│   данных      │       │
├───────────────┤    ───┘
. . .       . . .
├───────────────┤
│0 0 0 0 0 0 0 0│       нулевой байт-счетчик (терминатор блока)
└───────────────┘

     Расширенный  блок  GIF  может  непосредственно предшествовать
дескриптору изображения или находиться перед терминатором GIF.

     Все   декодеры   GIF   должны   быть   способны  распознавать
присутствие расширенного блока GIF и затем читать его, если они не
могут обработать функциональный  код. Это гарантирует,  что старые
декодеры смогут обрабатывать файлы изображений GIF в будущем, хотя
и без дополнительных функциональных возможностей.

                              - 9 -

                          ПРИЛОЖЕНИЕ A

                            ГЛОССАРИЙ

Пиксел  -  Наименьший  элемент  графического  изображения.  Обычно
   соответствует отдельной точке на графическом экране. Разрешение
   изображения обычно  задается в  пикселах.   Например, одним  из
   довольно стандартных экранных графических форматов является 320
   пикселов  по  горизонтали  на  200  по вертикали. Каждый пиксел
   может быть окрашен одним из нескольких цветов в зависимости  от
   возможностей графического оборудования.

Растр - горизонтальные уровни пикселов, представляющие одну строку
   изображения. Типичный  метод порождения  изображения, поскольку
   большинство образцов видеоборудования ориентировано на наиболее
   эффективную работу именно таким образом.

LSB - Сокращение от Least  Significant Byte ( младший по  значению
   байт).  Ссылается  на  соглашение  для  двух  байтов  числового
   значения,   согласно   которому   младший   по   значению  байт
   предшествует  более  старшему.  Такое  соглашение  типично  для
   микрокомпьютеров.

Таблица   цветов   -   Список   определений   для  каждого  цвета,
   используемый в изображениях GIF. Желаемые цвета  конвертируются
   в доступные цвета с помощью таблицы, причем по входным цветовым
   индексам  изображения  образуются  выходные  цветовые   индексы
   оборудования. Если для изображения GIF указана таблица  цветов,
   то   цвета   выходных   пикселов   будут   изменены  на  основе
   используемого  оборудования  и  его способности соответствовать
   заданным цветам.

Переплетение  -  Метод  высвечивания  изображений GIF, при котором
   совершаются  несколько  проходов  с  выводом  разнесенных строк
   растра,  что  дает  возможность  визуализации общего содержания
   всего изображения до того, как обработаны все данные.

B Протокол - Свободно распространяемый протокол передачи файлов  с
   исправлением ошибок, разработанный CompuServe и реализованный в
   продукте VIDTEX  фирмы CompuServe.  Такой механизм  обнаружения
   ошибок  будет  использован  при  передаче  изображений  GIF для
   интерактивных приложений.

LZW -  Совершенный алгоритм  сжатия данных,  основанный на работе,
   сделанной Lempel-Ziv и Welch, который обеспечивает  возможность
   высокоэффективного однопроходного кодирования и  декодирования.
   Это   позволяет   одновременно    раскрывать   и    высвечивать
   изображения. Исходная  статья, в  которой был  описан указанный
   метод:

          Terry   A.      Welch,    "A    Technique   for     High
          Performance   Data  Compression", IEEE Computer, vol   17
          no 6 (June 1984)

        Этот  базовый  алгоритм  также  используется  в   свободно
   распространяемых  утилитах  ARC  для  сжатия  файлов. Адаптация
   алгоритма  LZW,  выполненная  CompuServe  для  GIF  описана   в
   приложении C.

                             - 10 -


                          ПРИЛОЖЕНИЕ B

     ПОСЛЕДОВАТЕЛЬНОСТЬ ОБМЕНОВ GIF ДЛЯ ИНТЕРАКТИВНОЙ СРЕДЫ

     Для   управления   на   интерактивной   линии   связи   между
отправителем    и    получателем    GIF    определена    следующая
последовательность действий. Эта последовательность не применяется
в  приложениях,  включающих  загрузку  статических GIF-файлов и не
является частью GIF-файлов.

       ЗАПРОС ВОЗМОЖНОСТЕЙ GIF - GIF CAPABILITIES ENQUIRY

     Последовательность GCE идет из головного процесса и  требует,
чтобы интерактивный декодер GIF вернул ответное сообщение, которое
определяет графические параметры  для декодирования. Оно  включает
возвращаемую информацию о  доступных размерах экрана,  числе битов
на цвет и поддерживаемом количестве цветов. Esc-последовательность
для GCE определена следующим образом:

     ESC [ > 0 g     (g в нижнем регистре, пробелы вставлены для
                      ясности)
                      (0x1B 0x5B 0x3E 0x30 0x67)

     СООБЩЕНИЕ ВОЗМОЖНОСТЕЙ GIF - GIF CAPABILITIES RESPONSE

     Ответное   сообщение   о   возможностях   GIF    возвращается
интерактивным декодером и определяет возможности дисплея  декодера
для  всех  графических   режимов,  поддерживаемых   математическим
обеспечением. Заметьте, что  оно может также  включать графический
принтер, а не только экран монитора. Общий формат этого сообщения:

#version;protocol{;dev,width,height,color-bits,color-res}... <CR>
'#'          - GCR символ-идентификатор (Знак номера)
version      - номер версии формата GIF; начально '87a'
protocol='0' -  Протокол end-to-end  не поддерживается  декодером.
               Передача данных  ведется непосредственным  8-битным
               потоком.
protocol='1' -  Может поддерживать  протокол коррекции  ошибок при
               передаче данных от прямого хозяина на дисплей.
dev = '0'    - Далее следуют параметры экрана
dev = '1'    - Далее следуют параметры принтера
width        - Максимальная ширина дисплея в пикселах
height       - Максимальная высота дисплея в пикселах
color-bits       -   Поддерживаемое   число   битов   на   пиксел.
               Следовательно,    поддерживаемое    число    цветов
               2**color-bits.
color-res     -  Число битов  на компоненту  цвета, поддерживаемое
               аппаратной цветовой палитрой. Если color-res  равен
               '0', таблица аппаратной палитры недоступна.

     Заметьте, что  все значения  в GCR  возвращаются в десятичных
числах ASCII и сообщение заканчивается символом "Возврат каретки".

                             - 11 -

     Следующее  GCR-сообщение  описывает  три  стандартных  режима
EGA  с  конфигурацией  без   принтера,  поток  данных  GIF   может
обрабатываться в рамках протокола с коррекцией ошибок:
     #87a;1 ;0,320,200,4,0 ;0,640,200,2,2 ;0,640,350,4,2<CR>

                  ВВОД ГРАФИЧЕСКОГО РЕЖИМА GIF

     Две последовательности, определенные ниже вызывают для работы
интерактивный  декодер   GIF.    Между  ними   существует   только
единственное отличие.   Оно заключается  в выборе  различной среды
вывода. Эти последовательности:

  ESC [ > 1 g   Высветить изображение GIF на экране
                (0x1B 0x5B 0x3E 0x31 0x67)
  ESC [ > 2 g   Выдать     изображение      непосредственно     на
                присоединенный  графический  принтер.  Допускается
                также необязательный вывод на экран.
                (0x1B 0x5B 0x3E 0x32 0x67)

     Заметьте,    что    символ    'g',    заканчивающий    каждую
последовательность находится в нижнем регистре.

                       ИНТЕРАКТИВНАЯ СРЕДА

     Подразумеваемой средой  при пересылке  данных об  изображении
GIF в интерактивных  приложения является полностью  8-битный поток
данных от "хозяина" к  получателю. Об установке 8-битного  способа
пересылки  данных  при  связи  обычно  должна  заботиться головная
прикладная программа. Однако программа-получатель,  поддерживающая
декодер  GIF  в  линии  связи,  должна  быть  способна принимать и
передавать декодеру GIF все 256 возможных кодов 8-битных данных.

                             - 12 -

                          ПРИЛОЖЕНИЕ C

                  СЖАТИЕ И УПАКОВКА ИЗОБРАЖЕНИЯ

     Поток  растровых  данных,  которые  описывают  действительное
выходное изображение может быть представлен в следующем виде:

 7 6 5 4 3 2 1 0
┌───────────────┐
│  код размера  │
├───────────────┤     ───┐
│ байт-счетчик  │        │
│    блока      │        │
├───────────────┤        │
│               │        ├── Повторяется столько раз, сколько
│  байт данных  │        │   необходимо
│               │        │
├───────────────┤     ───┘
. . .       . . .
├───────────────┤
│0 0 0 0 0 0 0 0│    нулевой байт-счетчик
└───────────────┘    (заканчивает поток данных)

     Преобразование  изображения  из  серии  значений  пикселов  к
передаваемому или запоминаемому потоку символов включает несколько
шагов. Вкратце эти шаги состоят в следующем:

1.  Установка кода размера -  Определяет число битов,  необходимое
    для представления действительных данных.

2.  Сжатие данных  - Сжатие  серии пикселов  изображения в   серию
    кодов сжатия.

3.  Построение  серии  байтов  -  берет  серию  кодов  сжатия    и
    преобразует их в строку 8-битных данных.

4.  Упаковка байтов  - Упаковка  набора байтов  в блоки,   которым
    предшествует символ-счетчик и вывод.

                     УСТАНОВКА КОДА РАЗМЕРА

     Первый байт  в потоке  растровых данных  GIF имеет  значение,
указывающее минимальное число битов, необходимое для представления
для представления  действительных значений  пикселов. Как  правило
оно  будет  таким  же,  что  и  число  битов  цвета.  Однако из-за
некоторых ограничений  алгоритма черно-белые  изображения, которые
имеют один бит  цвета, должны иметь  код размера, равный  2. Такое
значение кода размера подразумевает также, что коды сжатия  должны
быть на один бит длиннее.

                             СЖАТИЕ

     Алгоритм LZW преобразует серию значений данных в серию кодов,
которые  могут  быть  самими  значениями  или кодами, описывающими
серию значений. Если использовать аналогию с текстовыми символами,
то выходные коды  состоят из символов  и кодов, которые  описывают
цепочки символов.

                             - 13 -
     LZW-алгоритм,    использованный    в    GIF    алгоритмически
соответствует стандартному алгоритму LZW со следующими отличиями:

1.  Определен  специальный  код  очистки,  который сбрасывает  все
    параметры  сжатия/раскрытия  и  таблицы  в исходное состояние.
    Значение этого кода равно 2**<код размера>. Например, если код
    размера  равен  4  (изображение  имеет  4 бита на пиксел), код
    очистки  равен  16  (двоичное   10000).   Код  очистки   может
    появляться  в  любом  месте  потока  данных  и, следовательно,
    требуется,  чтобы  LZW-алгоритм  обрабатывал  последующие коды
    так,  как  будто  бы  начался  новый  поток данных. Кодировщик
    должен выводить код очистки  в качестве первого кода  в каждом
    потоке данных изображения.

2.  Определен  код  конца  информации,  который явно указывает  на
    конец потока  данных изображения.  Если встретится  такой код,
    LZW-обработка  прекращается.  Этот  код  должен быть последним
    кодом,  формируемым  кодировщиком  для  изображения.  Значение
    этого кода равно <Код_очистки>+1.

3.  Значение первого доступного кода сжатия равно <Код_очистки>+2.

4.  Выходные   коды   имеют    переменную   длину,   начиная    от
    <код_размера>+1 битов на  код, до 12  битов на код.  Тем самым
    максимальное   значение   кода   определяется   равным    4095
    (шестнадцатиричное FFF).  Как только  значение LZW-кода  может
    превысить  текущую  длину  кода,  длина  кода увеличивается на
    единицу. Паковщик и распаковщик этих кодов должны  изменяться,
    чтобы соответствовать новой длине кода.

                   ПОСТРОЕНИЕ 8-БИТНЫХ БАЙТОВ

     Поскольку  LZW-сжатие,  используемое  для  GIF, создает серию
кодов переменной длины от 3 до 12 символов каждый, эти коды должны
быть переформированы в серию  8-битный байтов так, чтобы  на самом
деле   происходило   запоминание   или   передача   символов.  Это
обеспечивает дополнительное сжатие изображения. Коды формируются в
поток битов так, как если бы они паковались справа налево, и затем
выбираются по 8 битов для вывода. Рассматриваемый массив  8-битных
символов при упаковке кодов длиной по 5 битов должен быть похож на
следующий пример:

      байт n       байт 5   байт 4   байт 3   байт 2   байт 1
     ┌─.....─────+────────+────────+────────+────────+────────┐
     │ and so on │hhhhhggg│ggfffffe│eeeedddd│dcccccbb│bbbaaaaa│
     └─.....─────+────────+────────+────────+────────+────────┘

     Заметьте, что механизм  физической упаковки будет  изменяться
по  мере  того,  как  изменяется  число  битов  в  коде сжатия, но
концептуально он остается тем же самым.

                             - 14 -

                         УПАКОВКА БАЙТОВ

     Как  только  байты  созданы,  они  группируются  в  блоки для
вывода,  причем   каждому  блоку   предшествует  байт-счетчик   со
значением от 0 до 255. Блок с нулевым байтом-счетчиком заканчивает
поток данных для данного изображения. Эти блоки являются тем,  что
выводится  на  самом  деле  в  формате  GIF.  Такой  формат  блока
обеспечивает  дополнительную  эффективность  за  счет  того,   что
позволяет декодировщику  считывать данные  по мере  необходимости,
читая  сначала  байт-счетчик,  а  затем  пропуская  сами данные об
изображении.

                             - 15 -

                          ПРИЛОЖЕНИЕ D

                ОБРАБОТКА НЕСКОЛЬКИХ ИЗОБРАЖЕНИЙ

    Поскольку  поток   данных  GIF   может  содержать    несколько
изображений,  необходимо  описать  обработку  и высвечивание таких
файлов.   Поскольку  дескриптор  изображения  допускает размещение
изображения  в  пределах  логического  экрана,  можно   определить
последовательность изображений, каждое  из которых занимает  часть
экрана, но  их совокупность  заполняет экран  целиком. В  подобных
ситуациях  линии  поведения  при  обработке  изображений состоит в
следующем:

1.  Не  делать  пауз  между  изображениями. Каждое  обрабатывается
    сразу же, как только будет распознано декодировщиком.

2.  Каждое изображение  переписывает любое другое изображение  уже
    находящееся внутри его окна. Экран очищается только в начале и
    в конце обработки GIF-изображений. См. обсуждение  терминатора
    GIF.

                             - 16 -

                      ОБЪЯСНЕНИЕ LZW И GIF

      Я надеюсь,  что этот  маленький документ  поможет просветить
тех, кто хочет знать немного больше об алгоритме сжатия Lempel-Ziv
Welch и, конкретно, о его реализации для формата GIF.

     Перед  тем,  как  мы  начнем,  немного о терминологии в свете
данного документа:
"Символ":   фундаментальный элемент  данных.   В обычных текстовых
        файлах  это  отдельный  байт.  В  растровых  изображениях,
        которыми   вы   заинтересовались,   это   индекс,  который
        указывает  цвет  данного  пиксела.  Я  буду  ссылаться  на
        произвольный символ как на "K".
"Поток символов": поток символов такой, как файл данных.
"Цепочка":   несколько последовательных  символов.   Длина цепочки
        может изменяться от 1 до очень большого числа символов.  Я
        могу указывать произвольную цепочку как "[...]K".
"Префикс":  почти  то же самое,  что цепочка, но  подразумевается,
        что  префикс  непосредственно   предшествует  символу,   и
        префикс может иметь  нулевую длину.   Я буду ссылаться  на
        произвольный префикс, как на "[...]".
"Корень": односимвольная цепочка. Для большинства целей это просто
        символ, но иногда это может  быть иначе.  Это [...]K,  где
        [...] пуста.
"Код":   число,  определяемое  известным  количеством бит, которое
        кодирует цепочку.
"Поток  кодов":   выходной  поток  кодов,  таких  как   "растровые
        данные".
"Элемент": код и его цепочка.
"Таблица  цепочек":  список  элементов  обычно, но не обязательно,
        уникальных.

     Этого должно быть достаточно для понимания документа.

     LZW   -   это   способ   сжатия   данных,  который  извлекает
преимущества   при   повторяющихся   цепочках   данных.  Поскольку
растровые данные обычно содержат довольно много таких  повторений,
LZW является хорошим методом для их сжатия и раскрытия.

     В  данный  момент  давайте  рассмотрим  обычное кодирование и
декодирование с помощью LZW-алгоритма. В GIF используется вариация
этого алгоритма.

     При  сжатии  и  раскрытии  LZW  манипулирует тремя объектами:
потоком символов,  потоком кодов  и таблицей  цепочек. При  сжатии
поток  символов  является  входным  и  поток кодов - выходным. При
раскрытии  входным  является  поток  кодов,  а  поток  символов  -
выходным.  Таблица  цепочек  порождается   и  при  сжатии  и   при
раскрытии, однако она никогда не передается от сжатия к  раскрытию
и наоборот.
                              - 17 -

     Первой  вещью,  которую  мы  делаем  при  LZW-сжатии является
инициализация  нашей  цепочки  символов.  Чтобы  сделать  это, нам
необходимо выбрать  код размера  (количество бит)  и знать сколько
возможных значений могут  принимать наши символы.  Давайте положим
код размера равным 12 битам, что означает возможность  запоминания
0FFF, или 4096, элементов  в нашей таблице цепочек.  Давайте также
предположим, что  мы имеем  32 возможных  различных символа.  (Это
соответствует,  например,  картинке  с  32  возможными цветами для
каждого  пиксела.)  Чтобы  инициализировать  таблицу, мы установим
соответствие кода #0 символу #0, кода #1 to символу #1, и т.д., до
кода #31 и символа #31. На  самом деле мы указали, что каждый  код
от 0  до 31  является корневым.  Больше в  таблице не будет других
кодов, обладающих этим свойством.

     Теперь  мы  начнем  сжатие  данных. Давайте сначала определим
нечто,  называемое  "текущим  префиксом".  Этот  префикс  мы будем
постоянно  помнить  и  проводить  сравнение   с  ним  здесь  и   в
дальнейшем. Я буду обозначать его как "[.c.]". Изначально  текущий
префикс ничего не содержит. Давайте также определим также "текущую
цепочку",  которая  образуется   текущим  префиксом  и   следующим
символом в потоке символов. Я буду обозначать текущую цепочку  как
"[.c.]K", где K  - некоторый символ.

     Теперь посмотрите на первый символ в потоке символов. Назовем
его  P.  Сделаем  [.c.]P  текущей  цепочкой.  (В данной точке это,
конечно, корень P.) Теперь выполним поиск в таблице цепочек, чтобы
определить  входит  ли   в  нее  [.c.]P.    Конечно,  сейчас   это
произойдет,  поскольку  в  нашу  таблицу  при  инициализации  были
помещены все  корни. В  этом случае  мы ничего  не делаем.  Теперь
делаем текущим префиксом [.c.]P.

     Берем следующий символ  из потока символом.   Назовем его  Q.
Добавим текущий префикс,  чтобы сформировать [.c.]Q,  т.е. текущую
цепочку.  Выполняем  поиск  в  таблице  цепочек,  чтобы определить
входит ли в нее [.c.]Q. В данном случае этого, конечно, не  будет.
Ага!   Вот  теперь  нам  нужно  кое-что  сделать.   Добавим [.c.]Q
(которая в данном случае есть PQ) в таблицу цепочек под кодом #32,
и выведем  код для  [.c.] в  поток кодов.   Теперь начнем  опять с
текущего   префикса,   соответствующего   корню   P.    Продолжаем
добавление символов  к [.c.],  чтобы сформировать  [.c.]K, до  тех
пор,  пока  мы  не  сможем  найти  [.c.]K в таблице цепочек. Затем
выводим код для  [.c.] и добавляем  [.c.]K в таблицу  цепочек.  На
псевдо коде алгоритм будет описан приблизительно так:

     [1] Инициализация таблицы цепочек;
     [2] [.c.] <- пусто;
     [3] K <- следующий символ в потоке символов;
     [4] Входит ли [.c.]K в таблицу цепочек?
      (да: [.c.] <- [.c.]K;
            go to [3];
      )
      (нет: добавить [.c.]K в таблицу цепочек;
           вывести код для [.c.] в поток кодов;
           [.c.] <- K;
           go to [3];
      )

                              - 18 -

      Насколько это просто! Конечно, когда мы выполняем шаг [3]  и
в входном потоке не остается больше символов, вы выводите код  для
[.c.] и покидаете таблицу. Все сделано.

      Хотите   пример?    Давайте   предположим,   что   мы  имеем
4-символьный  алфавит:   A,B,C,D.   Поток  символов  выглядит  как
ABACABA.   Давайте  сожмем  его.   Сначала  мы инициализируем нашу
таблицу цепочек:  #0=A, #1=B,  #2=C, #3=D.  Первый символ  есть A,
который входит в  таблицу цепочек, следовательно  [.c.] становится
равным  A.   Далее  мы  берем  AB,  которая  не  входит в таблицу,
следовательно мы  выводим код  #0 (для  [.c.]), и  добавляем AB  в
таблицу цепочек с кодом #4.  [.c.] становится равным B.   Далее мы
берем  [.c.]A  =  BA,  которая   не  входит  в  таблицу   цепочек,
следовательно выводим код #1, и  добавляем BA в таблицу цепочек  с
кодом #5. [.c.] становится равным A. Далее мы берем AC, которая не
входит в таблицу цепочек. Выводим код #0, и добавляем AC в таблицу
цепочек с кодом #6. Теперь [.c.] равно C. Далее мы берем [.c.]A  =
CA, которая не входит в таблицу.  Выводим #2 для C, и добавляем CA
к таблице под кодом #7. Теперь [.c.]=A. Далее мы берем AB, которая
ВХОДИТ в  таблицу цепочек,  следовательно [.c.]  становится равным
AB,  и  мы  ищем  ABA,  которой  нет в таблице цепочек, поэтому мы
выводим код для  AB, который равен  #4, и добавляем  ABA в таблицу
цепочек под  кодом #8.   [.c.] равно  A. Мы  не можем  более взять
символов,  поэтому  мы  выводим  код  #0  для  A  и   заканчиваем.
Следовательно, поток кодов равен #0#1#0#2#4#0.

      Несколько  слов  (три)  следует  сказать  об  эффективности:
используйте стратегию хеширования.  Поиск в таблице цепочек  может
быть  сопряжен   со  значительными   вычислениями  и   хеширование
значительно снижает эти затраты.   Обратите внимание, что  "прямое
LZW"  сжатие  работает  с  риском  переполнения  таблицы цепочек -
получается код,  который не  может быть  представлен числом битов,
ранее установленных  для кодов.   Существует несколько  путей  для
того,  чтобы  справиться  с  этой  проблемой и GIF реализует самый
простой из них. Мы будем делать также.

      Важным  моментом,  на   который  стоит  обратить   внимание,
является  то,  что  в  любой  точке  во  время  сжатия выполняется
условие:  если  [...]K  входит  в  таблицу  цепочек, то [...] тоже
входит в  нее. Это  обстоятельство приводит  к эффективному методу
запоминания цепочек  в таблице.  Вместо того,  чтобы запоминать  в
таблице всю  цепочку, используйте  тот факт,  любая цепочка  может
быть представлена как префикс плюс символ: [...]K. Если вы вносите
[...]K в  таблицу, вы  знаете, что  [...] уже  находится в  ней, и
поэтому вы можете запомнить  код для [...] плюс  замыкающий символ
K.

      Это все,  о чем  следует заботиться  при сжатии.  Раскрытие,
возможно более сложно концептуально, однако программная реализация
его проще.

                              - 19 -

      Опишем как это делается.  Мы опять начинаем с  инициализации
таблицы  цепочек.  Эта  таблица  образуется  исходя из тех знаний,
которыми  мы  располагаем  о  порождаемом  в  конце  концов потоке
символов, например, о  возможных значениях символов.  В GIF-файлах
эта информация находится в заголовке, как число возможных значений
пикселов. Однако, прелесть LZW состоит в том, что это все, что нам
нужно.  Сжатие  было  выполнено  таким  образом, что мы никогда не
встретим в потоке кодов код, который мы не могли бы  преобразовать
в цепочку.

      Нам необходимо определить нечто, называемое "текущим кодом",
на  что  мы  будем  ссылаться  как  "<code>", и "старым кодом", на
который  будем  ссылаться  как  "<old>".  Чтобы  начать распаковку
возьмем первый код.  Теперь он становится  <code>. Этот код  будет
инициализировать  таблицу  цепочек  в  качестве корневого. Выводим
корень в поток символов. Делаем этот код старым кодом <old>.

     (*)  Теперь  берем  следующий  код  и присваиваем его <code>.
Возможно, что  этот код  не входит  в таблицу  цепочек, но давайте
пока   предположим,   что   он   там   есть.    Выводим   цепочку,
соответствующую <code>  в поток  символов.   Теперь найдем  первый
символ в цепочке, которую вы  только что получили. Назовем его  K.
Добавим его к префиксу [...], сгенерированному посредством  <old>,
чтобы получить новую цепочку [...]K. Добавим эту цепочку в таблицу
цепочек и установим старый код <old> равным текущему коду  <code>.
Повторяйте от того места, которое я обозначил звездочкой и вы  все
сделаете.   Прочтите   этот  абзац   еще  раз,   если  вы   только
"пробежались" по нему!!!

     Теперь  давайте  рассмотрим  ту  возможность,  что  <code> не
входит в таблицу цепочек. Вернемся обратно к сжатию и  постараемся
понять, что происходит, если во входном потоке появляется  цепочка
типа  P[...]P[...]PQ.  Предположим,  что  P[...]  уже  находится в
таблице,  а  P[...]P  -  нет.  Кодировщик  выполнит грамматический
разбор P[...], и обнаружит, что P[...]P отсутствует в таблице. Это
приведет к выводу кода для  P[...] и добавлению P[...]P в  таблицу
цепочек.  Затем  он  возьмет  P[...]P  для  следующей  цепочки   и
определит, что P[...]P  есть в таблице  и выдаст выходной  код для
P[...]P, если окажется, что P[...]PQ в таблице отсутствует.

      Декодировщик   всегда   находится   "на   один   шаг  сзади"
кодировщика.  Когда  декодировщик  увидит  код  для P[...]P, он не
добавит  этот  код  к  своей  таблице  сразу,  поскольку ему нужен
начальный символ P[...]P для  добавления к цепочке для  последнего
кода P[...],  чтобы сформировать  код для  P[...]P. Однако,  когда
декодировщик найдет  код, который  ему еще  неизвестен, он  всегда
будет   на   1   больше   последнего   добавленного   к   таблице.
Следовательно,  он  может  догадаться  что  цепочка для этого кода
должна быть  и, фактически, всегда будет правильной.

     Если  я  декодировщик,  и  я  увидел  код #124, а моя таблица
цепочек содержит последний код только с #123, я могу считать,  что
код с  #124 должен  быть, добавить  его к  моей таблице  цепочек и
вывести саму цепочку. Если код #123 генерирует цепочку, на которую
я сошлюсь здесь как на префикс  [...], то код  #124 в  этом особом
случае  будет  [...]  плюс  первый  символ [...]. Поэтому я должен
добавить первый символ [...] к ней самой. Не так плохо.

                              - 20 -

     В качестве  примера (довольно  часто встречающегося)  давайте
предположим, что мы имеем  растровое изображение в котором  первые
три  пиксела  имеют  одинаковый  цвет.   Т.е.  мой  поток символов
выглядит как : QQQ....  Для определенности давайте скажем, что  мы
имеем 32 цвета и Q соответствует цвету #12. Кодировщик сгенерирует
последовательность кодов  12,32,....   (если вы  не поняли почему,
возьмите минуту, чтобы понять.) Вспомним, что код #32 не входит  в
начальную  таблицу,   которая  содержит   коды  от   #0  до   #31.
Декодировщик увидит код #12 и транслирует его как цвет Q. Затем он
увидит код #32, о значении которого  он пока не знает. Но если  он
подумает о нем достаточно долго,  он сможет понять, что QQ  должно
быть элементом #32 в таблице  и QQ должна быть следующей  цепочкой
вывода.

     Таким  образом,  псевдо  код  декодирования можно представить
следующим образом:

     [1] Инициализация строки цепочек;
     [2] взять первый код: <code>;
     [3] вывести цепочку для <code> в поток символов;
     [4] <old> = <code>;
     [5] <code> <- следующий код в потоке кодов;
     [6] существует ли <code> в таблице цепочек?
      (да: вывод цепочки для <code> в поток символов;
            [...] <- трансляция для <old>;
            K <- первый символ трансляции для <code>;
            добавить [...]K в таблицу цепочек;
            <old> <- <code>;
      )
      (нет: [...] <- трансляция для <old>;
           K <- первый символ [...];
           вывод [...]K в поток символов и добавление его к
                        его к таблице цепочек;
           <old> <- <code>
      )
     [7] go to [5];

      Опять же,  если вы  обнаружите на  шаге [5],  что нет больше
символов,  вы  должны  закончить.   Вывод  цепочек  и   нахождение
начальных  символов   в  них   ставят  сами   по  себе    проблемы
эффективности,  но  я  не  собираюсь  здесь  предлагать способы их
решения.  Половина  удовольствия  от  программирования  состоит  в
разрешении подобных штук!

                              - 21 -

      ---
      А  теперь  вариации  GIF'а  на  эту  тему. В части заголовка
GIF-файла существует  поле, называемое  в потоке  растровых данных
"кодом размера". Это весьма запутывающее название для этого  поля,
но мы должны с ним смириться.   На самом деле это "размер  корня".
Фактический  размер  (в  битах)  кодов  сжатия  в действительности
изменяется в процессе сжатия/раскрытия, и я буду ссылаться на него
здесь, как на "размер сжатия".

     Начальная таблица, как обычно, содержит коды для всех корней,
но  к  ее   верхней  части  добавляются   два  специальных   кода.
Предположим, мы  имеем "размер  кода", который  обычно равен числу
битов на пиксел. Обозначим его N. Если число битов на пиксел равно
1, N должно равняться 2: корни занимают ячейки #0 и #1 в начальной
таблице и  два специальных  кода будут  занимать ячейки   #4 #5. В
любом другом случае N равно числу битов на пиксел, корни  занимают
ячейки от #0 до #(2**N-1), а специальные коды равны (2**N) и (2**N
+ 1).

     Начальный размер сжатия будет равен N+1 биту на код. Если  вы
ведете кодирование, вы выводите  сначала коды длиной (N+1)  бит и,
если вы ведете  декодирование, вы выбираете  сначала (N+1) бит  из
потока кодов. В качестве специальных кодов используются:  <CC> или
код очистки, равный (2**N),  и <EOI> или конец  информации, равный
(2**N  +   1).   <CC>   говорит  кодировщику,   что  нужно   снова
инициализировать таблицу  цепочек и  переустановить размер  сжатия
равным  (N+1).   <EOI>  означает  что  кодов  больше нет.  Если вы
ведете кодирование или декодирование, вы должны начать  добавление
элементов  в  таблицу  цепочек  с  <CC>  +  2.   Если  вы   ведете
кодирование, вам  следует вывести  <CC> в  качестве самого первого
кода, и  затем опять  каждый раз,  как только  вы достигните  кода
#4095 (шестнадцатиричное FFF), поскольку GIF не допускает  размера
сжатия  большего  12  бит.  Если  вы ведете раскрытие, вам следует
реинициализировать вашу таблицу цепочек, как только вы  обнаружите
<CC>.

     Переменный размер сжатия на  самом деле не доставляет  особых
хлопот. Если вы ведете кодирование вы начинаете с размера сжатия в
(N+1) битов, и, как только вы выведете код (2**(размер сжатия)-1),
вы  увеличиваете  размер  сжатия  на  один  бит.    Следовательно,
следующий код вашего вывода будет  на один бит длиннее.   Помните,
что наибольший  размер сжатия  равен 12  битам, что  соответствует
коду 4095. Если вы достигли этого предела, вы должны вывести  <CC>
в  качестве  следующего  кода  и  начать  сначала.  Если вы ведете
декодирование, вы должны увеличить ваш размер сжатия КАК ТОЛЬКО ВЫ
запишите  элемент  #(2**(размер  сжатия)  -  1) в таблицу цепочек.
Следующий код, который вы ПРОЧИТАЕТЕ будет на один бит длиннее. Не
делайте ошибки, дожидаясь, пока вам будет нужно добавить к таблице
код (2**размер сжатия). Вы уже пропустили бит из последнего кода.

     Упаковка  кодов  в  битовый  поток  растровых  данных   также
является   потенциальным   камнем   преткновения   для    новичков
кодирования и декодирования. Младший  бит кода должен совпадать  с
младшим доступным битом первого  доступного байта в потоке  кодов.
Например, если  вы начали  с 5-битного  кодов сжатия,  и ваши  три
первых кода,  скажем, <abcde>,  <fghij>, <klmno>,  где   e, j, и o
биты #0, ваш поток кодов начнется как:

                              - 22 -

       byte#0: hijabcde
       byte#1: .klmnofg

      Таким  образом  различие  между  обычным  LZW  и LZW для GIF
заключаются  в  наличии  двух  дополнительных  специальных кодов и
переменном размере  сжатия. Если  вы поняли  LZW, и  вы поняли эти
различия, вы поняли все!

      В  качестве  P.S.  Вы  могли  заметить, что кодировщик имеет
небольшую  битовую  гибкость  во  время  сжатия. Я описал "жадный"
способ, выбирающий  перед выводом  кода настолько  много символов,
насколько  это   возможно.   Фактически   такой  способ   является
стандартным для LZW и дает в результате наилучшую степень  сжатия.
Однако,   нет   никакого   правила,   которое   запрещало  бы  вам
остановиться и вывести код для текущего префикса, вне  зависимости
от того, есть ли он уже в таблице или нет, и добавить эту  цепочку
плюс  следующий  символ  в  таблицу  цепочек. Существуют различные
причины,  чтобы  пожелать  это  сделать,  особенно,  если  цепочка
слишком длинна и порождает трудности при хешировании. Если вам это
нужно, сделайте это.

                              - 22 -

          Мною были изучены стуктуры BMP и GIF файлов. А также рас-
смотрены и проанализированы работы предыдушего курса по этому мате-
риалу. На основе правильных суждений написаны программы: конверторы 
и просмоторщики: 
1. Просмоторщик BMP файлов - было дописано часть программы, которая 
позволяет просматривать стандартные BMP файлы (320x200).
2. Просмоторщик GIF файлов - написана программа позволяющая 
просмататривать GIF файлы, созданные по алгоритму LZW и его вариаци-
ей (320x200).
3. Конвертор BMP -> GIF - конвертирует из стандартного BMP файла в 
GIF файл (который описан выше).
4. Конвертор GIF -> BMP - конвертирует в стандартный BMP файл 320x200,
который можно просмотреть любым программным продуктом поддерживающий 
этот формат.     
      Как было сказано создается GIF файл по алгоритму LZW и его вари
ации, который не просматривается программными продуктами такими как:
PV, PhotoEditor, Internet Explorer (другими не пробовал).
      Программа создает почти тот же GIF-файл (одинаковы: идентификатор 
GIF, дескриптор экрана, глобальная таблица цветов, дескирптор изображения,
терминатор GIF),существенное отличие заключается в самих растровых данных.
Сравнения проводились после конвертирования разными програмными продуктами 
из одного BMP файла в GIF файл, получались разные растровые данные у всех
файлов GIF соответственно. Отличие заключается в том (на мой взгляд),что 
каждый по своему варьирует инициализацию кода очистки и переменного кода 
длины (судя по первым байтам в растровых данных). Так как мне не известны 
секреты алгоритмов конвертирования в программных продуктах, было оставлено
пока все на последнем уровне и написан собственный просмоторщик для GIF 
Файлов.     
          



             