.MODEL SMALL
.STACK 100h
.DATA
	old_bx dw ?
	old_es dw ?
	outmes db 0	;флаг 1 когда успешно отправлено
	inmes db 0	;флаг 1 когда успешно передано
	mess db 'TRANSMITTER',0dh,0ah,'$'
.CODE
START:

	;ПОДМЕНА ПРЕРЫВАНИЯ
	mov ax, 350Ch           ; AH = 35h (чтение текущего вектора обработчика  COM порта), AL = номер прерывания
    int 21h                 ; получить адрес обработчика
    mov word ptr old_bx, bx ; и записать его в ОЗУ
    mov word ptr old_es, es
    mov ax, seg REC		;сегмент процедуры пользовательского обработчика
	mov ds, ax
    mov dx, offset REC		;смещение процедуры пользовательского обработчика
	mov ax, 250Ch		;используем 25 функцию 21 прерывания для записи в таблицу векторов прерываний сигмента и смещения пользовательского прерывания (DS:DX)
    int 21h
	
	;ИНИЦИАЛИЗАЦИЯ COM порта
	mov ax,80h 
	mov dx,3FBh		 ;задать скорость
	out dx,al 	 
	mov ax,0Ch		 ; Установить делитель на скорость 9600 bit\s
	mov dx,3F8h 		; Записать младшее значение делителя в регистр данных
	out dx,al
	mov al,0    
	mov dx,3F9h		; Записать старшее значение делителя
	out dx,al   
	mov ax,00100011b 	; Передаем байт настройки(см "форматы обмена")
	mov dx,3FBh 		;Заносим в dx адрес регистра управления линией 3fbh
	out dx,al			;запись
	mov ax, 00000011b	;разрешить прерывания по приему и передаче (см "форматы обмена")
	mov dx,3F9h 				
	out dx,al

waitread_t: ;модуль отправки
	mov dx, seg mess	;помещаем в DS:DX сегмент и смещение массива с сообщением
	mov ds, dx		;из ОЗУ в DS писать нельзя, поэтому через DX
	mov dx, offset mess 	;передача смещения в dx для вывода сообщения 
	mov ah,9   					;вывод
	int 21h
	mov cx,20		;считать символ с клавиотуры
	mov ah,01h
	int 21h
	cmp al, 1bh		;если введен Esc, то выход
	je exit
	mov outmes, 0		;очистить флаг чтобы не перезаписывать байт
	mov dx,3F8h  		; Заносим в регистр dx адрес 3f8h
	out dx,al			; Пишем байт
check_t: 			;проверяем флаг отправки, ждем опустошения буфера (отправки)
	mov al, outmes	
	cmp al, 1
	je waitread_t		; Если флаг равен 1, то ждем следующий символ
	jmp check_t
	
REC proc far  
cli   				;запрещаем маскируемые прерывания  
mov dx, 03fah  			;выбираем регистр, идентифицирующий прерывания  
in al, dx   			;читаем из него в al  
mov dl, al  			;заносим введенный символ в dl  
and al, 00000110b		 ;наложение маски. 
cmp al, 00000100b 		;проверяем, равен ли он 10 - данные приняты и доступны для чтения, сброс – по чтению из 3F8
jne NEXT_REC  		;если нет, переходим на END_REC  
mov inmes, 1			;если да, выставить флаг приема
NEXT_REC:
and al, 00000110b 		;наложение маски для проверки отправки. 
cmp al, 00000010b		 ;проверяем, равен ли он 01 – данные переданы, сброс – по записи в 3F8
jne END_REC  			;если нет, переходим на END_REC  
mov outmes, 1			;если да, выставить флаг успешной передачи
END_REC:       
mov al, 20h   			;сброс флага наличия прерывания (отправка EOI)
out 20h, al   			;  (отправка EOI)
sti    				;разрешаем маскируемые прерывания 
iret   				 ;выход из процедуры 
REC endp 

exit:   
	mov dx, old_bx  		;заносим в dx адрес смещения исходного обработчика     
	mov ax, old_es  		;заносим в аx адрес сегмента исходного обработчика     
	mov ds, ax   		;перемещаем его в ds     
	mov ax, 250Ch   		;функция установки вектора    
	int 21h  		 	;восстанавливаем вектор     
	mov ah, 4ch
	int 21h			;выход
END START
