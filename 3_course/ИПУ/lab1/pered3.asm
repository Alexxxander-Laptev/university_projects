.MODEL SMALL
.STACK 100h
.DATA
	keep_cs dw 0 ; хранит сегмент заменяемого прерывания
	keep_ip dw 0 ; хранит смещение заменяемого прерывания
	sent db 1
	firsymbol db 3
.CODE
START:
	cli ;запрещаем маскируемые прерывания
	in al, 21h ; читаем порт 21h
	and al, 07h ; запрещаем прерывания COM-порта
	out 21h, al ; записываем порт 21h
	sti ; разрешаем маскируемые прерывания

	mov ax, 3bh ; настройка линии; 00111011
        mov dx, 3FBh ; выбор регистра
        out dx, ax 

	;; задание скорости
        mov al, 0ch ; младший байт делителя частоты
        mov dx, 3F8h
        out dx, al
        mov al, 00h ; старший байт делителя частоты
        mov dx, 3F9h 
        out dx, al 

	mov ax, 00000010b ;разрешение прерываний только для передачи
	mov dx, 03F9h ;выбор регистра разрешения прерываний(ier)
	out dx, ax
	
	mov ch, 1eh ; инициализация ch
	mov ah, 35h ; функция получения вектора
	mov al, 0ch ; номер вектора
	int 21h ; теперь сегмент в es, смещение в bx
	
	mov keep_ip, bx ; запоминаем смещение
	mov keep_cs, es ; запоминаем сегмент
	
	mov dx, offset REC ; смещение для процедуры в dx
	mov ax, seg REC ; сегмент процедуры
	
	mov ds, ax ; помещаем в ds
	mov ah, 25h ; функция установки вектора
	mov al, 0ch ; номер вектора
	int 21h ; меняем прерывание
TRY:
	mov ax, 0040h ; заносим в ах начало сегмента, в котором расположен буфер клавиатуры
	mov ds, ax ; перемещаем его в ds
SCAN:
	mov al, ds:001ch ; читаем указатель на логический конец буфера(туда будет записан следующий введенный символ)
	cmp al, ch ; сравниваем его с предыдущим значением
	je SCAN ; если указатель не изменился, то переходим на SCAN

	;; иначе обновляем предыдущее значение
	mov ch, al 
	mov ds:001ah, al ; устанавливаем значение логического начала равным значению логического конца, для обнуления буфера
	cmp al, 1eh ; проверяем, совпадает ли логическое начало с физическим(необходимо из-за цикличности буфера)
	jne BUFFER ; если конец буфера не достигнут, то переходим напрямую к чтению
	mov al, 3eh ; заносим адрес физического конца буфера(необходимо из-за цикличности буфера)
BUFFER:
	mov ah, 00h ; обнуляем регистр, чтобы не испортить адрес
	mov di, ax ; заносим указатель в di
	mov al, [di-2] ; читаем последний введенный символ
	cmp al, 1bh ; проверяем, была ли это клавиша esc
	je EXIT ; если да, переходим на EXIT
	
	mov sent, 0
	mov dx, 3F8h 
	out dx, al ; записываем введенный символ
	mov bl, al ; заносим введенный символ в bl
WAITSEND:
	mov dx, 3FAh ; выбираем регистр, идентифицирующий прерывания
	in al, dx

	; проверяем, равен ли второй бит прочитанного байта 1
	and al, 00000010b
	cmp al, 00000010b 
	jne WAITSEND ; если нет

	;; функция для вывода содержимого регистра dl на экран
	mov ah, 02h 
	mov dl, bl
	int 21h 
	jmp SCAN 

	;; Вход в процедуру
	REC proc far
	
	cli ; запрещаем маскируемые прерывания
	mov dx, 3FAh ; выбираем регистр, идентифицирующий прерывания
	in al, dx ; читаем из него в al
	mov dl, al ; заносим введенный символ в dl

	; проверяем, равен ли второй бит прочитанного байта 1
	and al, 00000010b
	cmp al, 00000010b
	jne END_REC
	mov sent, 1
END_REC:
	mov al, 20h ; разрешаем все прерывания
	out 20h, al ; аппаратные прерывания
	sti ; разрешаем маскируемые прерывания
	iret ; выход из процедуры
	REC endp
EXIT:
	cli ; запрещаем маскируемые прерывания

	;; восстанавливаем вектор
	mov dx, keep_ip ; заносим в dx адрес смещения исходного обработчика
	mov ax, keep_cs ; заносим в аx адрес сегмента исходного обработчика
	mov ds, ax ; перемещаем его в ds
	mov ah, 25h ; функция установки вектора
	mov al, 0ch ; номер вектора
	int 21h
	
	sti ; разрешаем маскируемые прерывания

	mov ah, 4ch ; функция завершения программы
	int 21h 
END START
