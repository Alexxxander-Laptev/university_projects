.MODEL SMALL
.STACK 100h
.DATA
	keep_cs dw 0 ; хранит сегмент заменяемого прерывания
	keep_ip dw 0 ; хранит смещение заменяемого прерывания
.CODE
START:
	cli ; запрещаем маскируемые прерывания
	in al, 21h ; читаем порт 21h
	and al, 07h ; запрещаем irq4 (прерывания COM-порта)
	out 21h, al ; записываем порт 21h
	sti ; разрешаем маскируемые прерывания
	
	mov ax, 3bh ; настройка линии
	mov dx, 3FBh ; выбор регистра
	out dx, ax ;запись в порт

	; задание скорости
	mov al, 0ch ; младший байт делителя частоты
	mov dx, 3f8h 
	out dx, al 
	mov al, 00h ; старший байт делителя частоты
	mov dx, 3f9h
	out dx, al

	mov ax, 0003h ; установка линии в режим приема данных
	mov dx, 3FBh ; выбор регистра управления линией(lcr)
	out dx, ax

	mov ax, 01h ; разрешение прерываний только для приема
	mov dx, 3F9h ; выбор регистра разрешения прерываний(ier)
	out dx, ax ; запись в порт

	mov ch, 1eh ; инициализация ch
	mov ah, 35h ; функция получения вектора
	mov al, 0ch ; номер вектора
	int 21h ; теперь сегмент в es, смещение в bx
	
	mov keep_ip, bx ; запоминаем смещение
	mov keep_cs, es ; запоминаем сегмент
	mov dx, offset REC ; смещение для процедуры в dx
	mov ax, seg REC ; сегмент процедуры
	mov ds, ax ; помещаем в ds
	mov ah, 25h ; функция установки вектора
	mov al, 0ch ; номер вектора
	int 21h ; меняем прерывание
TRY:
	mov ax, 0040h ; заносим в ах начало сегмента, в котором расположен буфер клавиатуры
	mov ds, ax ; перемещаем его в ds
SCAN:
	mov al, ds:001ch ; читаем указатель на логический конец буфера(туда будет записан следующий введенный символ)
	cmp al, ch ; сравниваем его с предыдущим значением
	je SCAN ; если указатель не изменился, то переходим на SCAN
	mov ch, al ; иначе обновляем предыдущее значение
	mov ds:001ah, al ; устанавливаем значение логического начала равным значению логического конца, для обнуления буфера
	cmp al, 1eh ; проверяем, совпадает ли логическое начало с физическим(необходимо из-за цикличности буфера)
	jne BUFFER ; если совпадает, то переходим на REASSIGN
	mov al, 3eh ; заносим адрес физического конца буфера(необходимо из-за цикличности буфера)
BUFFER:
	mov ah, 00h ; обнуляем регистр, чтобы не испортить адрес
	mov di, ax ; заносим указатель в di
	mov al, [di-2] ; читаем последний введенный символ
	cmp al, 1bh ; проверяем, была ли это клавиша esc
	je EXIT ; если да, переходим на EXIT
	
	mov dx, 3F8h
	out dx, al ; записываем введенный символ
	
	mov dl, al ; заносим введенный символ в dl
	mov ah, 02h ; функция для вывода содержимого регистра dl на экран
	int 21h ; вызов функции
	jmp SCAN
	
	REC proc far
	
	cli ; запрещаем маскируемые прерывания
	mov dx, 3FAh ; выбираем регистр, идентифицирующий прерывания
	in al, dx
	mov dl, al ; сохраняем прочитанный символ в dl
	
	and al, 04h ; наложение маски. результат равен 4, если второй бит прочитанного байта равен 1
	cmp al, 04h ; проверяем, равен ли он 4
	jne END_REC ; если нет, переходим на END_REC
	
	mov al, dl ; восстанавливаем символ из dl
	
	or al, 0FDh ; наложение маски. результат равен fd, если первый бит прочитанного байта равен 0
	cmp al, 0FDh ; проверяем, равен ли он fd
	jne END_REC ;если нет, переходим на END_REC
	
	mov dx, 3F8h ; иначе выбираем регистр приемника(rbr)
	in al, dx
	
	cmp al, 0FFh ; проверяем, не пришло ли ff
	je END_REC ; если пришло, переходим на END_REC
	
	mov dl, al ; заносим прочитанный символ в dl
	mov ah, 02h ; функция для вывода содержимого регистра dl на экран
	int 21h ; вызов функции
END_REC:
	mov al, 20h ; разрешаем все
	out 20h, al ; аппаратные прерывания
	sti ; разрешаем маскируемые прерывания
	iret ; выход из процедуры
	REC endp
EXIT:
	cli ; запрещаем маскируемые прерывания
	
	mov dx, keep_ip ; заносим в dx адрес смещения исходного обработчика
	mov ax, keep_cs ; заносим в аx адрес сегмента исходного обработчика
	mov ds, ax ; перемещаем его в ds
	mov ah, 25h ; функция установки вектора
	mov al, 0ch ; номер вектора
	int 21h ; восстанавливаем вектор
	
	sti ; разрешаем маскируемые прерывания
	
	mov ah, 4ch ;функция завершения программы
	int 21h ;вызов функции
END START
